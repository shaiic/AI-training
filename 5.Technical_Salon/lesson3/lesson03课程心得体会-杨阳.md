
# 微软-仪电人工智能高阶人才培训学习心得之一：201课程-数学基础---线性代数 概率统计

# 作者：杨阳（上海仪电人工智能创新院有限公司）

本周课程是关于线性代数以及概率统计内容的。线性代数与数理统计是本科基本数学内容，理解起来并不困难，难点在于如何用python库去实现。Barture老师生动活泼的课堂氛围给了我们很多启示，除了知识之外，也提供学习方法供我们参考。

## 线性代数课程总体感受
线性代数主要学习了向量与矩阵，初始python中并不支持向量与矩阵的直接运算，这就需要用到python的函数库，最主要的就是 scipy 库与 numpy库，特别是numpy库，基本上常用的向量与矩阵的计算都涵盖其内。再辅助以matplot 绘图库，更加直观。numpy库几乎都有相应的函数可以直接调用，比起通常的自定义list方法从间接程度、易学程度以及运算效率上都有极大的提升。


### 向量 
> 有值和方向的量

假设在二维平面有一个点 x = 2, y = 1

\begin{equation}\vec{v} = \begin{bmatrix}2 \\ 1 \end{bmatrix}\end{equation}

向量就可以用图像表示为有长度有方向的箭头。通过以下代码可以将向量可视化出来。


```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "last_expr"
# %matplotlib inline
import math
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
v = np.array([2,1])
origin = [0], [0]
plt.axhline()
plt.axvline()
plt.axis('equal')
plt.grid()
plt.ticklabel_format(style='sci', axis='both', scilimits=(0,0))
plt.quiver(*origin, *v, scale=10, color='r')
plt.show()
```


![png](output_2_0.png)


需要注意的是numpy默认是弧度制，可以通过`math.degrees()`来将弧度制转化为角度制。但是对于常用的科学计算，还是用弧度制更加合理。

### 向量的运算
向量运算，除了向量的和，更多用到的是向量的模与向量的乘积。
对于向量的模，数学上称为向量的范数，表示向量的长度。在numpy库中，可以用np.linalg.norm(v)来计算对应范数，常用的范数有1范数，无穷范数以及欧几里得范数，其中，欧几里得范数是np.linalg.norm(v)的默认范数，是对于二维空间向量长度在n维空间的扩展，暨对应对标的平方和的开方。

常用的向量乘法有以下几种：

- 标量乘
- 点积
- 叉积

其对应的物理含义为：

- 标量乘对应于伸缩，计算方式为直接用`*`乘即可

- 点积对应于做功，计算方式为`np.dot(v1,v2)`

- 叉积对应于角惯量，计算方式为`np.cross()`

##  矩阵

矩阵是二维数组，是线性空间之内，找到合适的基，用向量可以表示线性空间里任何一个对象。线性空间中的运动，被称为线性变换。也就是说，从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。在线性空间中，当选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。简而言之，在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。矩阵的本质是运动的描述。更准确的说，矩阵是线性空间里跃迁的描述。

###  矩阵的运算
numpy中自带了很多函数可以进行矩阵的运算，常用的举例如下：
- solve 解方程组
- norm 求标量
- @ 求积
- inv 求逆
- eig 求解特征向量和特征值

###  矩阵特征值的含义理解

特征值和特征向量表达了一个线性变换的特征。在物理意义上，一个高维空间的线性变换可以想象是在对一个向量在各个方向上进行了不同程度的变换，而特征向量之间是线性无关的，它们对应了最主要的变换方向，同时特征值表达了相应的变换程度。
具体的说，求特征向量，就是把矩阵A所代表的空间进行正交分解，使得A的向量集合可以表示为每个向量a在各个特征向量上的投影长度。我们通常求特征值和特征向量即为求出这个矩阵能使哪些向量只发生拉伸，而方向不发生变化，观察其发生拉伸的程度。这样做的意义在于，看清一个矩阵在哪些方面能产生最大的分散度，减少重叠，意味着更多的信息被保留下来。

## 生命游戏

这是个模拟生命演化的游戏，在一个广阔的生存空间里，设定生命群落存活和繁衍的规则，个体和群落依据既相互竞争又相互依存的法则进行进化。

### 总的规则

- 过于拥挤的分布 - 资源争夺 - 死亡
- 过于孤立的分布 - 不具备种群优势 - 灭绝
- 适度的分布 - 繁衍

### 规则细节

- 少于2邻居，死
- 多于3邻居，死
- 正好3邻居，生

对于生命游戏，可以有普通的python解法，如下。


```python
import random as random
import timeit

# 产生一个百万0，1数组，0代表空（死），1代表生
Z = [[random.choice([0,1]) for x in range(1000)] for y in range(1000)]

# 计算八个邻居数目
def neighbours(Z):
    s = len(Z), len(Z[0])
    # 一个初始全为0的邻居数量矩阵
    N = [[0,]*(s[0]) for i in range(s[1])]
    for x in range(1, s[0]-1):                                  # 注意边界
        for y in range(1, s[1]-1):
            N[x][y] = (Z[x-1][y-1] + Z[x][y-1] + Z[x+1][y-1] +  # 邻居数量=周围8个格子生命统计
                       Z[x-1][y]               + Z[x+1][y]   +
                       Z[x-1][y+1] + Z[x][y+1] + Z[x+1][y+1])
    return N

# 根据周围邻居总数应用规则
def evolve(Z):
    s = len(Z), len(Z[0])
    N = neighbours(Z)
    for x in range(1, s[0]-1):
        for y in range(1, s[1]-1):
            if Z[x][y] == 1 and (N[x][y] < 2 or N[x][y] > 3): # 灭亡规则
                Z[x][y] = 0
            elif Z[x][y] == 0 and N[x][y] == 3:               # 繁衍规则
                Z[x][y] = 1
    return Z

print(timeit.timeit(lambda: evolve(Z), number=3))             # 对百万人口作三代进化，统计运算效率
```

    2.6929967870000837


也可以用python进行计算，经过优化如下解法


```python
import timeit
import numpy as np

Znp = np.random.randint(2, size=(1000,1000), dtype=np.int8)

def no_loop_int_view_reduce_rule_no_mask(Z):
    N = np.zeros(Z.shape, dtype=np.int8)
    N[1:-1,1:-1] += (Z[ :-2, :-2] + Z[ :-2,1:-1] + Z[ :-2,2:] +
                     Z[1:-1, :-2]                + Z[1:-1,2:] +
                     Z[2:  , :-2] + Z[2:  ,1:-1] + Z[2:  ,2:])

    Z[...] = 0
    Z[1:-1,1:-1][(((N == 2)[1:-1,1:-1])&(Z[1:-1,1:-1] == 1))|(N == 3)[1:-1,1:-1]] = 1
    
print(timeit.timeit(lambda: no_loop_int_view_reduce_rule_no_mask(Znp), number=3))
```

    0.035156062000169186


显然，通过numpy解法，使得计算速度提升了两个数量级。

### 生命游戏可视化的联想
对于课堂上的可视化例子，我想起了读书时曾经使用过的netlogo语言。NetLogo是一个用来对自然和社会现象进行仿真的可编程建模环境，不只是一个简单的语言，而是集成了语言与编程环境与可视化于一体的利器。

netlogo是由Uri Wilensky在1999年发起的项目，由连接学习和计算机建模中心（CCL）负责持续开发。NetLogo是一系列源自StarLogo的多主体建模语言的下一代，并在StarLogo的基础上增加了一些新的特性，在语言和用户界面上有所更新。这一软件是用JAVA实现，能够在大部分主流平台（如Mac、Windows、Linux等）上运行，目前可供使用的有客户端和网页版版本。Netlogo可以非常容易地进行仿真，或者创建自己的模型，能够运用于多个学科和领域。

NetLogo特别适用于随时间演化的复杂系统建模。通过向成百上千独立运行主体（Agent）发出指令，能够探索微观层面上个体行为与宏观层面上环境模式之间的联系。这些宏观模式更多地是由个体之间的交互行为所展示出。

下面是netlogo的相关链接，容易学习，简单易懂但功能强大，特别是可视化与演示化方面。

NetLogo 4.0.2 中文用户手册, http://ccl.northwestern.edu/netlogo/4.0.4/docs/NetLogo_manual_chinese.pdf

NetLogo Home Page, http://ccl.northwestern.edu/netlogo/

NetLogo的扩展，https://github.com/NetLogo/NetLogo/wiki/Extensions

##  概率论与数理统计

概率论与数理统计内容基本上就是学校教学基本内容，主要体现在如何python实现，利用numpy与scipy库基本上可以处理绝大多数实际遇到的问题。


##  分糖游戏的感悟

问题：13块糖分给3个小朋友，有多少种分法。
显然，糖是一样的，小朋友是不一样的。如果上来硬算，肯定不是最合理的方法。即使算对了也太费人力。在课堂上barture老师通过引导我们将此问题拆解，将聚焦点从小朋友身上放到糖上面，将分糖给3个小朋友转换成加入2个分隔符，一下子将分糖问题变成了分隔符放置问题。显然，如果小朋友可以没有糖，那么有$ \begin{equation} C^{2}_{15} \end{equation}$种分法，如果要求每个小朋友必须有糖，则有$ \begin{equation} C^{2}_{12} \end{equation}$种分法。一下子将问题简化了。

听老师说这是他小学儿子的问题，我一方面觉得现在小朋友负担太重，这么难的题这么小就要接触；另一方面也感慨，从小就学习转换问题的思维，或许这就是现在小朋友超越我们这一代人的地方，后生可畏，自己更不能松懈。

##  总结
经过三周的学习，跟着Barture老师从零基础开始学习python以及用python来解决常用数学问题，自己的眼界开阔了，思路更加清晰。接触了很多以前没有接触过的工具与思想。自己受益良多。

最后感谢Barture老师，感谢我们的校长和助教团队，特别谢谢我的TA曾老师。

# 关于微软-仪电人工智能创新院
微软-仪电人工智能创新院将由微软和仪电共同运营和管理，致力于为微软和仪电在人工智能方面的联合研究活动和项目提供支持，为当地企业提供基于微软技术的人工智能研发平台服务和培训服务。

# 关于人工智能高阶人才培训班

微软和仪电共同打造的人工智能高阶人才培训班由创新院运营，第一期历时三个月，授课老师包括来自微软和仪电的多位专家，内容涵盖人工智能导论、数学基础、深度学习、应用实例等课程，以及关于强化学习、自然语言处理、计算机视觉等热门方向的专题研讨会，希望帮助学员掌握人工智能的理论与实践，培养具备前瞻视野和实践能力的创新型人才。



更多信息，请关注微信公众号
![二维码](./image/barcode.jpg)


```python

```
