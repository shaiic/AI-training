# **Reorganize the in-class lesson notes from live video_20190531**
## 1

好的，咱们开始吧，都已经9:30了，然后，那个今天我看你们都换了自己的笔记本了，环境都可以连接吧，就能连上是吧？就是上周高冲
帮你们弄了一下环境，然后那个环境里面，跟咱们上次不太一样的地方，就是，git在那个doctor里面了，就是原来那个git在外面，git
在doctor里面，所以，你们要到这个这里去更新一下代码，就是你打开一个terminal. 然后在这里get. pull，然后最新的一个commit是
加fix之类的。有没有上次没有来的同学？然后大家都更新到了最新的代码了，然后，更新到最新的代码以后，我们今天继续讲python后
面的部分，然后主要.弄好了吗？有没有还没好的？举下手，大家等他一下。那个你们回去上周都试了那个jupyter，自己在里面搞一搞，
然后熟悉一下环境。就是，高冲库里的Doctor image上应该是我又加了一个git，然后这种操作不是经常发生， 因为我们很少改系统，如
果你们自己感兴趣，或者你们上周自己回去pull过这个image的话，可能需要update一下，有一些新东西可以加进去，我的这个MAC上的
image应该不是最新的，等他pull一下，这个新的folder就是高冲给你们，就是如何搞这些git，更新代码的一个教程，然后我们今天开始
，上次我们大概讲了这个课里面前三部分，都是，编程环境变量，还有这个函数，就是python的语法，我们差不多都过了一遍，就是最基
本的语法，这是你写程序必须要用到的，然后其实如果你，如果你在这个语法的方向上深钻了， 你还可以研究很多东西，还可以讲上，比
如一两天的课，但是呢，我们下面的课，比方说，neural network讲这个machine learning，我们要用到的很多东西，都跟这个库有关，
比方说，我们现在有个基本的语法，我们可以给python写一些程序，然后在某种程度上来说呢，python其实是直接库的一个粘合器，就是
说，他把这些库能粘在一起，然后可以很方便的去调用这些库的功能，然后今天呢，我们主要是来介绍这些库，这些库呢？这个标题不是
很概括，我后来又加了一些东西，我们今天介绍4个库，就是，分别是这个，munpy，scipy，为什么画成这个形状呢？因为我不知道你们有
没有兴趣他这个，我们随便打上一课，本来今天要讲的这个课，然后在这个help里面你会看到很多，很多list，就是我们今天讲的课的所
有的document的reference.都在这里面， 其实这些库都是一个时期开发的，就是他们很早就开始做数据计算，做科学计算，相关的库都是
他们弄的，你会看到他们家的产品，我们除了倒数第二个，就是符号计算，这个课程你会接触到其他的，然后他大概是一个什么样的流程
啊？如果你画一条数据轴的话，你可以想象一下，这是数据流动的方向，data流动的方向，任何时候你想处理数据或者，做一些计算，他
的输入肯定很大，所谓的big data. 或者是比较的，不那么整齐，就需要清洗，然后你通过这些拿到的数据，我的某种影响，这种影响往
往到后面你会catch看起一个image，就是关于这些数据还有，连接的内在规律之间的一个图像，那你怎么得到一个非常形象的图像呢？你
中间其实要做很多计算，这是我的输入，然后，然后这是我的输出结果，我的输入经过pandas，做各种各样的处理，然后算各种各样的
统计特征，然后把它导入到下一个阶段，然后下个阶段就是，用一些数学计算的工具，他们有两个，她们就是numpy和scipy，其实我们原来
这个课里面没有cover这个scipy，后来我发现这东西就是说，也需要讲一下，他俩的区别是什么？它小，你可以把它认为它是一些最通
用的库的集合，它大，他有很多他没有的功能，或者所，你可以认为它是它的一个超集，numpy是scipy的一个集，他俩侧重点不太一样，
为什么要这样？为什么不直接用一个scipy？因为是尺寸的原因，scipy要比numpy大很多，另外一个原因就是，其实，很多时候就是，那些
公式你去实现它，一个数学公式变成一个可以执行的代码，你会发现只要有numpy就足够了，然后当我们算出一些结果来以后，我们希望画
一个图形，画一个图形把它展示出来，然后算出一个图像，你就可以知道，直接知道结果，然后这就是我们今天主要想讲的内容，就是这4
个库，然后，关于这个库呢，我们可能在今天下午或者今天上午结束的时候，跟大家讨论一下，做学习和使用，如果大家感兴趣的话，可
以再深入的使用一下，就是这些库你表面看起来很好掌握的，很好使用，但是它里面其实是有一些在表面看不出来，隐藏在深处的trick，
我们先开始吧，先让我们来看看他的文档，大家也可以去看一看，就是点一下那个link就可以跳到numpy的document的首页，然后在这个
document的首页我们要看什么呢？我们要看，左边那个toc. 他的库里面到底有什么东西？就说我们先把它过一遍，这是通常用一个库的时
候你不会上来就开始写代码，你会先看一看他要干什么？然后这个过程一般就是从上下的看一下它的结构是什么？他这个文档是什么样子
的？他在basic里面有read. 有basic operation. 大家注意一下这个东西。就是我们上周讲过一个list，讲过list的index，然后大家如
果有其它语言背景的话，语言什么的。上周我们也试过在一个list上面，有各种各样的index，非常灵活，然后numpy他引入了更多的复杂
性，然后index对他来说非常非常重要，如果大家感兴趣的话，我们下周做，做一个布置作业，就是你几乎所有的思维都是在折腾这个
index. shape，大家看到的事就会联想到一个什么样的问题，就是，就是他不是一维的。

## 2

阿妈，list没有shape，list就是一串数字不存在shape的问题，就是你是多维的，你才shape问题，就是2x2，3x3，也就是说，numpy可
以处理多维数字，然后下面一个重要的概念就是，copies and views. 最后我们会看到我们会演示这一点，这个东西其实，怎么说呢，
就是从设计上来说，你想给用户提供一个非常简单易用的系统的话，那么你就要做一些取舍，我觉得就是我们我们今天讲课的很多内容
都可以python list来实现，但是我们为什么不用python，虽然它很好用，但是，他提给我们提供便利性的同时，也牺牲了性能，也就是
说在当这两者在做权衡的时候，我们可能会选择便利性，就比方说我们一开始学编程的时候，我们就会选简单的，非常容易上手，可以直
接看到结果，但是，随着你的课程的深入，随着我们学习的深入，我们想实现一些目的，然后我们发现，这些便利性其实给我们带来了很
大的性能负担，那么这时候我们就要翻过去去翻看，再看原来的那些决定，包括python做这些design，decision. numpy做这些design，
decision，我们就要翻过头来再看，站在一个开发者，或者站在这库的设计者的角度，重新思考一下这些，便利性跟性能之间，怎么样去
做取舍，然后，才会有这样的话题，copy和view，什么是copy和view，你在python list里面不会接触到这样的概念，然后，下面有这些
basic. 我们不是说要把整个numpy的库都过一遍，里面可能有几百个函数调用，所以，我们只是cover最基本的东西，然后，给大家一个
入口，给大家知道去如何去哪里找这些文档，然后呢，我们会着重讲一些概念，然后比如说像这些内容，index triples，其实这个部分
，copy and views还要跟前面提到的index, 他们其实是一起的，你们以后写程序，可能在某些阶段第1步，我先把它做出来，我先看到
一个结果，你会发现这个结果其实很慢才出来，然后我想调优，我想把它跑得更快一点，然后就需要深入的去读这些文档，这些文档还
是很关键的，然后我们回到刚才的这个页面，这是大概了解一下，就说我们为什么要搞一个这个东西出来？为什么不直接用list？有两
个主要原因，第1个原因就是说慢，那其实你还是可以去解决，比如说慢就慢，反正能算出来，还有一个问题就是它可能很麻烦，它可能
会导致你不断运行的慢，而且你写code的速度也慢，你写出来的code也很难被别人理解，就是阅读啊，什么的都会慢，我们看一下，这
是一个sample code，然后，这个sample code 就是我们除了这个，引入这个umpy以外，我们在这个课上基本都是用，都是用这个，一般
我们引入一个库，给这个库起一个名字，那么为了你阅读的方便，你就有一些规则，比如说，把它import成这个名字，我们之后的代码
都是这个样子，为了方便，pandas啊pd啊，乱七八糟的名字，然后这是要干一些什么事情呢？，就是，这明显是在比较这三种实现的速
度，以后你们可以看一下这个结果，这个结果其实还是很让人吃惊的，这里至少有一个量级上的差别了，然后这个和这个就是整个差了
，两个量级的，所以为什么？他干了什么，他是40万长的一个数据，然后一开始把他们弄成0. 40万个零，然后再把它们刷一遍，刷成一
，大概就是干这样的事情，然后第1个他就是用list来实现的，一个数组循环40万次，我刚说反了，应该是一层至为0. 我刚才说反了，
先搞成1，看反了，这一个L，这是一个1，他们很像，其实1是绿色的，他的意思就是我先跑一遍，40万个1，然后再把这40万给一改成0.
 然后它运行了这么长时间，然后我们看numpy的操作，numpy的操作，差不多，他有一个单独的操作叫once. 你们可以查一下，就是我再
 给大家讲一下，大家可以快速的查一下，numpy有数据类型，我们搞这个浮点数，40万个1.0. 然后这个是什么意思？这个是全部，全部
 元素都的意思，你会看到我们这里，在这里你会发现，你在表明上不会看到任何for循环，你好像就是一个很长的赋值，其实是两次赋
 值，这是一次赋值，这是一次赋值，中间有个view是个很怪异的语法，那个东西我们很容易理解，就是一个，这里不是好容易看懂，但
 是基本的结构大概他要干什么？你把它换成一个非常紧凑的数值，然后你会发现他俩差两倍，嗯，为什么会有这样的区别？我们用了嗯
 python里面的一个model就是，来计算这个运行时间，我下面写的这个是一个比较啰嗦的写法，但是这个document里面其实可以查到的
 ，最简单的方法就是Google. 如果你们预习过的话，这是我在里面有link你们应该都看过，就是讲怎么搞这个time，他有个工具，叫ti
 meit，timeit就是他说的很直白，你有好几种用法就是，最简单的用法就是我这有一小段code，我也懒得写一个python.我就把它弄到
 一个字符串里面，就像这样，然后你用这个module，你往里面放这个string，他可以自动选择，这个东西在干什么？这个东西其实，嗯
 1234567，就是直接到100. 把它串起来，中间用dash把它连起来，然后但是他会把这段code run很多遍，然后看他的时间是多少，这点
 很重要，因为用他的库的时候，你一开始可能会没有处理到这个，会自动给你加这个run多少次，你也可以把它当作一个python module
 来用，就像我用一样，然后注意后面有一个number. 他是干嘛的？就写那个number等于1万，这就跟上面那个code的效果是一样的，当
 然他还有一些调用底下的，我们都没有用到，其实我们就用它记一下时，这个总行吧。好，回到这来，大家可以反过来想一下就是为什
 么，他怎么这么快？为什么能快100倍？看起来是一个很简单的操作，快在哪？有没有idea，可以猜一下他为什么这么快，空间还是时
 间上？他放的紧密一点，占的内存少，他俩其实占的内存差4倍，你说他比他的内存大100倍会这样吗？大家觉得跟数据类型有关系，因
 为我事先知道他多大，然后还有我可以把它放得更紧密一些，然后我们来猜想一下就是，如果我们自己来做这件事情，你还记得上次我
 们讲过，一个类似你是可以无限这样子演的，这是一个整数，这是一个bool，如果你是要支持一个这样的数据结构的话，你想想你至少
 需要，加一个tag吧，还有一个问题就更棘手了，我不知道下一个是什么，所以我每次都要来重新初始化一下，初始化下一个元素，这
 个东西就麻烦了，因为如果你成乘以40万，这可能就会变成一个很大的开销，而且它不是线性的，就比如说一段code，我们可能会消耗
 掉，一小段内存，然后100个code就会消耗100个内存，时间也会百倍这样吗？no，为什么这样说呢？因为，一旦你频繁的操作内存操作
 系统，系统可能会换页，这个我们就这样讲一下吧，比方说你在计算的时候，你有几种速度的level就是，如果这段发生在这一层，这
 一层是最快的，它上面有一层cache就是，这是离CPU最近的一段存储器，如果计算都发生在这一层，你还是算快的l1. L 2. 你再往下
 就是，都到了memory. 这一段是非常大的，你往下掉大约10的三次方10的4次方，再往下就是IO，IO又分为两种，现在看来已经不是特
 别明显了，磁盘，hit，刚刚说的换页是什么意思？就是你allocate很多memory，你allocate memory 的时候，系统不是你allocate一
 个字节就给你一个字节，他会给你很多，等下一个requiret给你更多的，你memory会出现这样的情况，就是说，我一开始要求一点点他
 给你这么多，然后这些东西就空着，我要求这么多，他要给我这么多，然后这些东西又空着，然后你反反复复做这些操作的话，你的me
 mory里面就有很多这个小洞，然后系统会发现你的memory不够了，然后它就会产生这样的一个操作，他会停下来，他会有一个中段停下
 来，然后，一段memory里面的数据写到磁盘上，然后把另一个程序需要的他的memory. 从磁盘里再读出来，然后这里面就牵扯到一个非
 常大的操作，然后这个操作会使得整个，allocate memory deallocate memory就会变成这样的曲线，这就是这个问题的关键，就是这
 个跟python一点关系都没有，python从来不讲这些的，他的意思就是说你不需要关心，我来帮你控制内存，实际上你搞一个这样的数，
 他是管不好的，然后numpy他会处理这件事情，然后为什么numpy可以做到一个python做不到？我们回想一下刚才的那个，如果我们抛开
 这些语言，语法，我们不管用什么程序语言写程序，最终他都会变成一些操作系统内核的程序，然后操作系统就会用一些内核程序来用
 ，这两个是最常见的就是，这两个你们可以查一下，跟操作系统要一段内存，然后搬运这些内存，如果你从物理上看，计算机的话，他
 大部分的操作都是在干这个，你也不管他是什么程序去实现，我就在检查这些电路，看看他在干什么，而且就是把一张内存搬过来搬过
 去，其实中间那个计算非常快，在CPU上很快的处理一遍，然后又回到内存里面去了，我想这个memory allocation，我刚才说的那个
 问题也是不可避免的，这比方说你们有没有印象，就是用一些，都是一些很老的，不是ssd的磁盘，为什么你们听的那个链接声音这是
 为什么？然后你系统慢的时候就是不知道他在干什么，他其实就是在捣鼓内存，它的内存不够了，非常容易不够，你因为你从来不释
 放，你一直在要，从来不Free的，而且关键的问题不是只有你的程序在跑，这是不是除了我们现在在运行的jupyter的后面，还有十几
 万个程序在跑，大家一起在抢夺这个资源，这个问题是很严重的，然后你会发现自己的mwmory什么时候都是不够的状态，随便打开一
 个程序，等于就赚了十几g的memory. 然后就是memory copy。这个copy我们刚刚回想起来，我们一开始看的嗯document里面有copy an
 d view，memory copy，其实你想想，这个东西其实也很麻烦的，因为，Memory copy其实意味着我要把这一段，复制到这里来，我至
 少要用两倍的空间，在copy发生的时候有两块空间，所以很想让他中断CPU. 如果我把它算到时间里面的话，这个东西也很费时，你只
 要记住在python，只要你写了一个赋值的语句，他都意味着memory copy，就是他把这个东西省略掉，就是我们知道他这个东西一直都
 是一个整数，然后在这个程序运行期间，也不变化，就比如我们这个例子，从一变成0这样子，就是我们没有copy，我们直接去改，我
 们直接从memory. 把那些1改成0.应该是最快的， 然后如何你避免拷贝，在python整个语言里面，就没有一个语法，或者说是，没有
 一个地方，一个开关，你把它打开的时候就不要考呗，zero copy，就是做不到，也没有一个贪官能告诉你zero location，因为它是
 一个自动帮你分辨。然后我希望有一些库能帮我们管理这些问题，其实就是我们刚刚说的内容，大家对慢怎么来的有一个感性的认识
 ，就像刚刚那样子的小程序就能看到，另外很显然那就是为什么吗？他物理上的原因很好解释，他语法上的原因不能解释，我们并没
 有写错程序，多写了很多什么的，它不是一个语法的错误，程序语言设计上的问题，因为我们选了python，python简单，他就有代价
 ，我们来看下一个问题，就是有些数学操作不支持，什么叫有些数学操作不支持？我们回忆一下，上周我们算了一个身高体重指数，
 我们现在任务不是算自己的身高体重指数，比方说我们算我们小组的，算这个教室里所有同学的指数，算全上海的人的指数算全中国
 人的指数，这里有一个身高，这个数，这里有一堆体重这个数，我们希望直接这样一算，大家可以试一下，不能算，他不让你这么算
 ，他如果不让你这样算怎么办？就是要循环，因为很恶心这个你看这个多好，这个一目了然，就因为多了就要循环，有的时候循环不
 是很好，其实跟上面一样的，我就故意加了一个这个，我们就在用numpy，我还是用刚刚那个已经定义好的list，这是我们用的第一个
 ，numpy我们给的一个list，这个list不能乱掉，还是刚刚的那些数，，这样字就可以来，这是我们想要的结果，你看，这多好，这个
 如果我给你一个公式，你就照着抄一遍，结果就直接出来了，看起来都是正确的值啊，这就是我们为什么要引入numpy？因为它快，它
 可以做一些list他做不了的事，然后我们把这个公式更新一下，上周写公式的时候没有这个东西。
 
 ## 3
 
 说明我们一些公式的符号，这个符号的意义变了，不是一个数值，它是一个向量，然后，你会发现这是一种特别强大的思维工具，就是，我们会定义在我们上小学学的算术，比如加法，然后，我们上中学的时候，可能，中学的时候也讲来行列式，向量这些概念，然后我们向量的加法，然后同样是加法，但是我们只是把操作数变了，但是概念还是一样的，向量也有加成这样的概念，但是你看这个公式，它还是非常简单的形式，就是，但是你要知道他代表的是什么意思，这是你的思维一下子跳了一个维度，你从一个zero demision操作变成了一个one dimision的操作，如果你能跳这个维度的话，你可以再往高阶去跳，非常复杂的想法，就像你的思维可以在一个很像地图的结构里面，就可以看到全局，就可以看到非常detail的地方，然后你就可以在2个纬度上随意切换，这就是数学思维带给我们的好处，这是一个非常好的，我们还记得上次的时候我们说我们做一个运算的时候我们找出一个判断，dmi是不是大于21，这好像是一个身材好的标准，然后这5个可以同时算，然后你可以发现我们刚才说的这是一个向量，然后你会发现它是一个数，还可以把一个数和一个值做一个运算，然后，跟他，就是如果你没有上下文的话，你会觉得这是一个值，你会把它变成一个bool array， 然后这个时候你的思维就还是在high level上运行，你还是在一维的空间里面，第1个一维数组，变成一个一维的bool的数组，我们试一下这个。我们这个就是说我们刚刚算出来一个数是21.几几几，我们觉得太啰嗦了，我们就要一些简单的数，21 22这样的整数，取整，你会发现取整不支持，他没有define这个python，这样干不行，但是这样干可以，但是你也不知道什么时候这样搞，直接就可以了，这样是不行，其实有个好办法就是，可是他肯定不会忘了，你如果弄错他会有一个error. 然后你错过一次两次，你渐渐的就记住了，是的，你试错是一个你记忆的方法，你看以前那个做条件反射的实验，就是这个套路，你弄错了打你，疼了又疼，他肯定记住了，我们也是跟动物，我们和他们一样的，其实就是在一个这个，这些地方就是说，比一定要想当然的，你要知道这件事是perfect的，我们来想一想为什么是这样子的，为什么不能直接搞，原因是什么，看起来没有什么很复杂的东西，why？其实是因为numpy里面有的做了重载，有的没有做重载，它不能重载整个python的操作空间，它常用的能重载，不太常用的他就不重载，所以我们就会掉在这个坑里了，我们就要写一个麻烦的东西，但无所谓，这不算一个很严重的事情，这个可以，我就试了一下，就是说我们猜刚才那个大于号的事情，max是一个比较常见的操作，你可以这样搞，我们已经测试了一下，这两max是不一样的，这是一个库的，这是python的一个function，现在再来一个练习，这个练习是干什么的呢？我们刚才讲在high level上，这个vector上的维度上取思考问题，去做计算，现在把两个数加起来，把两个数字加起来，你可以想象一下，如果，你用python取这么做，就是，你能不能避免写一个for循环，加起来是这个意思，什么是数组加，就是有2个数组，这里一个，这里有三个函数，这里123,45就是对应的位置加，然后变成一个数，2个vector变成一个vector，你们可以自己想一想，或者自己试一试，我在下面有答案，其实你也能看到的。就是，我没来比较一下这两种做法，我们可以看一看，我们搞一万和数，1到一万，然后，同样，我们也搞numpy这个数，我们用list来加，看一下这个zip，zip是一个很好玩的操作，zip就是拉链嘛，拉拉链，你的拉链有很多齿，比如说他对应了一个齿，zip就是说他有2个数组，你把它想象成两个拉链，然后，kick相应的2个位置然后拿出来，然后这2个数做一个操作，所以这个操作以后就存在一个结果里面了，然后我们做的一个操作就是加，然后，这就是我们想的向量加，很直观，然后，它更直观，他就add，我们能不能直接写n1加n2，我们来试一下，对的，他两差多少，他两差得多，它两是2个量级了，3个量级了，他两差3个量级，原来是100倍，反正总之你知道有些操作你用numpy能快2个量级，不是2倍，2个量级是100倍，就是很让大家吃惊的一件事，所以还是值得学。然后这个语句我们和刚才比较一下，刚才我们也写过，大家还有印象吗，你看，我们写了这种东西，还有个这玩意，有一个叫setup，好像很啰嗦的话，你看这个字符串，就是他有2种接口，第一，你给他一个string，然后它把它当成一段code，但这段code他又没办法直接用，因为这段code是一个函数调用，函数调用是在这定义的，这函数调用是在上面定义的，就你还得来一个incall，把这个函数定义导进去，然后就写出来这么长一段，他都放不下了很啰嗦，非常啰嗦，我们不喜欢啰嗦的事情，然后，下面这个写法跟他是一样的，但是呢，好像跟美观一点，看起来没有那些乱七八糟的引号之类的，这个比较好。但是，这个东西我们上节课讲过吧，lambda，讲过，无名函数，这里的lambda，叫无名函数，这个有个函数名 ，这是怎么回事，它的意思是我定义了一个函数，这个函数只调用它，这里其实有2个function，它在call的时候是有2个function，一个是lambda，一个是list，它其实应该打引号引起来慢一点，Q：解释一下lambda含义 A:lambda是这个含义这个所有的function，我们习惯上都来一个这个东西，先define一个function，然后你才能用这个function，可不可以不define直接用？就是，你看，我上周的时候也讲过，我这里有个数，就是我可以这样的，比方说，这里有个数，是吧，这里有第二个数，然后，我说把这两个数加起来，这是可以的，是吧？我们肯定知道这能算出一个值，但是，我为什么要让他占用一个名字呢占用一个memory的location呢？我就是先算一个值，这不是也可以吗，对吧，那function可不可以这样，不要这个东西了，直接在用它的地方定义，对吧，因为，这个就是它，n1，变量的定义那我们就是说，这个东西冒号之后的这个逗号之前的是这和function的定义，然后，但是，这个语法也很怪，它原来没有这个东西，python2没有这个lambda这个东西他是后来才引用的，所以，他得加一个关键字，加一个保留字，就是lambda，加inverse word，就是我这后面有一个lambda。比方说，不知道有没有同学用过JavaScript的，JavaScript function，后面是可以没有命名的，然后你这call后面可以直接function，所以有一种说法，一种分类，就是叫函数式编程，lambda是一个非常非常关键的概念，如果你的语言不支持lambda，你就不能说我的是函数式语言，函数式的语言和大家想象的不太一样的是，就是说，它不是说我们来搞一个function call 不是的，它的源头是所有东西都可以是function，除了function它没有别的东西，也就是说，您看，我们现在写这种类c的语言，这个符号里面要放参数的，你知道的是吧，然后这个return后面跟的是返回值，在function call的language里面有个函数式，程序里面，大量的参数是function，大量的返回值是function，也就是说，如果你能，拿一个整形，一个数据类型当参数，你也可以拿一个function当参数，如果你能返回一个值，你也可以返回一个function，所以就是，你感觉这个程序写的很长，好像没有存任何数据，你的feeling是他没有存任何数据，他这就是他想达到的目的，就是他的数据是流过他的这段code的，这段code是stream list，就是说，他的code并不保留中间的状态，他只跟输入和输出有关系，那如果你的code是完全是这种状态的话，他就有个巨大的好处，因为它没有status，所以你可以随便分配它，比方说，就好像你们做过webservers，如果你后面这个东西不需要status，不需要handle season的话，你是可以随便弃的，你可以分发到后面好多的back上去，这也是他的好处，所以你，天然的进行处理，天然的可以做分布式，这是一个很有意思的方法，python其实借鉴了一些东西，但不是很多，这些不是我们要讲的重点，我们将的是数据计算这些的但是这个top很有意思。其实在这个Ai冬天到来之前，就是这些搞AI的人，其实都是用的，其实我刚才说的mca的语言。好继续往下。回答你的问题，这是什么玩意，这是最土的办法，不管怎么样，只要你有python的显示器，你一定能把文档调出来，这就是他的文档，然后我们往下看一下，很多，有很多状态，就我们刚才用的一个和这个很像的，用的是once，然后，他里面有一些例子代码，这里面因为有shape，的概念，你往下翻你有一种什么样的感觉，其实，上次我们也script了一个list，就是我们把这个list 的document也打印出来了，但是你看这里，这是scrip的位置，这个document非常非常长，我们应该只用来1/10都不到，所以它比list要大得多，所以你想象一下它的功能要比list大得多，所以只有可能它能做 list不能做的事情，不可能反过来，我们不是要挨个的讲一遍，太多了，但是，如果你什么时候需要用到，你就可以来查一下。大家下课了可以过一遍这个文档，就是你这种浏览，就是你虽然google，要用的tool，你可以去search，但是，一个关键的问题是，你输什么关键词，你要输入一个keyword，，你到时候我要找什么，这对你来说很有帮助，我们继续往下。
 
 ## 4
 
 我发觉大家有好奇心很好，为什么不叫array,你猜这个词应该叫什么意思啊，n dimension,如果你去设计（库的设计），你去想一想，你必须要搞一个除了数据以外，你还能想到什么，shape 比较关键，内存是一维的东西，就是一大长串空间，你要说明这个空间的layout，叫skima, 这是哪一行哪一列，每一个元素多大，这些information，如果大家感兴趣可以run一下。 它应该是个类，我们这里给了一个list。它如果转化以后应该会是怎么样？ 全部变成字符了？为什么，因为这里面有个字符串，其实你想一想，这就是一个二维结构。它是字符串的结合，字符里面也可以放一些复杂的东西串本身是一个list。所以你看这个结构能表示什么，这个结构其实可以表示article,我有一个文章，里面有很多单词，然后一个单词是一个字符串。然后我们就可以把这个文章变成一个数值。 好，其实这个符号你们能猜出来他是干嘛的，U是无符号，所以说我们来指定一下。
 
 好，我们来查一下document，类型，大小，然后字节句，前面这个符号是啥意思？，刚才我们看到这个u32是一个sign。他里面也可以放一些比较复杂的东西，我们很少用到一个structure或者是一个unicode, 我们用的最多的其实是数值（float）），字节句这个东西就是你在写c code啊要考虑的东西。这些东西比方说你碰到一个bug，你也不会特别去记住他，但当你去debug，你发现打印出来type不应该是这个样子，你就可以来查一些文档。
 
 讲到文档，刚才其实在上课的时候我给大家指出来，你什么都没带，就打开一个浏览器，这里有个help menu然后就可以access文档。然后我给大家讲一讲工具，这个dash，是给mac用的，我们看一下。用mac的同学可以装一下，现在下载装一下应该来得及。这个工具还是比较有用的，其实我很少用开发工具，我装的implication里面，其实跟开发相关的不是很多。因为我开发一般只用terminal。但是我会在mac上装一个叫dash的东西。然后这个windows的同学装一下这个东西，我没用过，大家可以装一个，我想这个大概意思其实差不多。那个dash是需要花钱把广告去掉（一个倒计时），但我想这个钱还是值的花，也不是很贵。然后这个好像也需要花钱吧。。。。 很慢是吧，下载里面doc慢，我来给你们演示一下，你看他powered好像是这些，这里面肯定有你以前用过的东西。有没有都用过的？这些我都接触过。好，剩下的我都用过，然后我推荐一个大家去看看，我个人觉得价值最高的，大家有兴趣的可以去看一下，你应该在工作中可能用不太到，但可能在这里会有很大的帮助，工作里面非常有用的会是这个东西，Rands, C++…..这些用数据库，还有些东西不要用。比方说，他的平台已经没有了，有一些其实是先把一个平台的语言挪到另外一个，这个是到linux上，但他俩实现很不一样。还有一些可能在历史上有用的，比如说ruby，十年以前做，还有一些其实是不好的事，我个人是这么觉得，有一些也不是特别有必要，有一些有好有坏，但是你还得用。

## 5

我们这里面有写过php的同学，如果你会php,其实python在莫种程度上是个降位，更简单了，更直观了，大家演示一下这个工具，其实大家也看过这个。然后它本质上是一个索引，你看他好像也是一个HTML，你看这里一个 ，他最根本的这个地方是一个索引，他相当于在你本地build了一个小的search engine，专门来search document。所以这个索引有什么好处，索引肯定就是快，你只要敲，他就会出来。他叫你搜的是个什么样类型的东西，这里有method， function一大堆。通常你可以这样子去搜，就是我能装什么document，这个大家明白吗，你看他可能windows界面也有这样的工具，我不是所有的document都装了，你看这些android， js…我都没装，如果你感兴趣你可以去装一下，很全，这个guru,你去做嵌入式的,还有我们用的bash。这个都是很小众的东西，只要你能想到的。其实有些东西并不是语言，开发库，他是一些产品，做search engine的时候，这些都是官方文档，官方文档就是说我有个project，然后这个project非常健康，维护的很好，我们有官方文档，然后他就去官方文档，一个网站，把这个文档搞下来。文档一般有一个html格式，他做索引的意思并不是一个full text searching, full text 就是一个字符串，我们在所有文档作匹配，不是的，他知道这些文档的结构，就比方说模块，类，方法，所以你会看到一个非常漂亮的这种样子的东西，比方说，随便打开一个跟今天不太相关的，像这个d file, 就是你在d file里面可以写的，那我们今天讲过的，他是一个非常稳定的结构，类型，方向，变量，然后下面还有这个，指南。 指南是什么，比方说我想了解一个专题，这个在网站上都有。比方说我特别感兴趣这个array，你会发祥他这个速度很快，就是说基本上秒出吧。实际上他已经在本地了，这是一个index,他已经在本地了，有一个cash，因为你通常在这里搜一个什么玩意儿比你去Google上要快一个量级吧。因为这种你的目的性非常明确，找到这个function的document，通常你会gap一个结果，大家回去以后，除了doc环境，你本机用的什么，这个东西没法搞到云上去啊，因为他有一个gy,你没法在云上用它。要在大家自己的，正好今天大家用自己的本，装这个东西，也可以快速search文档，这里面还有个，他还有些fancy的功能，可以给你们演示一下，他可以跟开发工具集成，他其实在你本地开了一个service，然后你这个开发工具可以调本地的service，然后开一个文档，然后就可以把比方说你coding的时候，这里有个method，你放上去，他document就出来了。因为有一些开发环境，比方说微软做的vs，他所支持的东西，他才有document很好的集成，我要在vs里面编一个他根本不支持的语言，我也想查文档，我不需要不停得type，这个其实很有用，基本上都是editor。然后大家可能下一步可以用到的edit，这里面不是很全啊，我们好像装了这个了，还有一个pycharm，上面这一行都是些general的editor.这就是文档，我们介绍的工具。大家一会儿有空可以下载完装上试试啊，我自己查。

然后我们刚才讲了numpy的入门，现在我们来点实用的东西，把前面那个例子扩大1000倍，就是我们要做一个模拟，什么叫做一个模拟，刚才那个例子我们只有五个人，这些数据我们都是敲上去的，你们如果想正儿八经得做一做，如果你想搞一个模型，你怎么来模拟这件事情，比方说你想计算上海的，整个东南地区所有人的身高体重指数，我有一个idea，我给大家一些启发。我随机抽取100个人，到大街上去找100个人，然后我就认为这100个人有代表性，然后我就用这100个人的数据搞一个模型，然后我就在上面做运算。大家有什么更好的想法，这不是一个数学问题，也不是一个编程问题，这纯粹是一个解决实用的问题。我们到大街上找100个人也要花不少小时，花钱雇人这是一个办法。高考体检数据，所有医院的数据大概要花多少钱，这是很现实的问题，要不要整个数据都拿过来。造数据啊，造数据的根据是什么，就是说用不着买，用不着买整个医院的数据，因为后面学数理统计，我哦们知道，某人张多高多胖跟另一个人是无关的，是吧，绝对是无关事件，也可能与关系，他俩可能基因上有关联，但这种很小，人群很大的话，我们认为任何任何两个人的身高体重都是无关的，如果都是无关的，我们就可以知道他的分布，差不多是正态分布，那对正态分布来说呢，我们只需要两个指标，其实我们就可以general。正态分布有期望，方差，提前查一下这个。应该还有印象。所以我们不需要买整个医院的数据，我们只需要知道那两个数就好。就是平均身高是多少，平均体重是多少，方差是多少。他有可能平均身高是这个，每个人的身高也是这个，国旗班，长得一样高，一样重，体型一模一样。我们只有一个期望还不够。
来，大家试一试这个文档，你可以点这个link，也可以拿手机扫。这个document其实是一个numpy的库，他在doc的set里面，大家看到吗？叫什么啊，这个东西在random下面,我们看一下他的文档，放在大屏幕上，大家一起看一看。然后看他们的参数，有三个参数。然后他的名字跟我们习惯叫的不一样，他叫skill, location. 这什么意思呢？他其实已经知道正态分布是个长这样的，然后我画的这个东西有点bias啊，正好他就在0这个地方，他可以不在0这个地方，他可以在这里。他可以很瘦，胖瘦这个我们管它叫skill，然后这个location就是说他在哪儿，想想一下小生命在数轴上移动，然后size什么意思，这个random的generator相当于生成一些随机数，不是生成一个随机数，而是生成一大堆，我们要生成多少个，然后正态分布有很多名字啊，normal，还有人管它叫高斯分布。我以前看过一个讲数学的东西，他说这是所有数学图形里面最重要的东西。你知道每个学科都有一个logo吗，你有一个shape，这能代表这个学科。这是什么，物理，。。。。。如果让大家画一个符号代表数学，会画一个什么？但是这个符号就知道的人更多，更有辨识度。三个参数，我们记住了，然后这是我的一个快照，用刚才的一个东西去搜一下也一样，很快就可以搜到。这是我找的数据，相当于医院里面搞出来的数据，然后这个数据还比较新，是2015年的。这个表有点小，然后是分地区的，华北，东北。。。，然后也是分男女的，然后有均值，标准差，大家看一下，不是一个数，是两个数，1693是身高，标准差是56，标准差感觉很大啊，（是公斤吗？）不不，他是标准差，差50多毫米，5厘米可以。因为我们一般说身高都不会说毫米，不会那么精确厘米，然后这个体重也是，还挺有意思的，你看必须是有差异的，我们看看什么人最轻，西南，西南的人最轻。他可能比东北，华北那里的人轻十公斤，轻二十斤。确实跟地域有关系啊。反正这些数据你一看get一个，这是一个真实的数据，然后我们就做我们这个地区吧，上海，上海应该算是东南地区啊，上海成年男性，平均身高不到一米七，然后体重一百一，不，体重是一百二。好，现在有身高体重的均值方差了，我们要生成一组数据。很简单，就把刚才的搞进去，但是注意一下我跟之前数据做了一下align，前面我们不是用毫米，是用米，然后公斤是一样的，5000个数据。然后这个sh是上海male吧，身高，体重，你看啊，现在我们把它弄在一起，我们要自己造了一个数据，大概5000个样本，然后造的这个数据就是把两个样本给摞起来，就是说，有两列，这一列是身高，这一列是体重，numpy它提供了这种reshape的function call,这就是一个reshape，我现在有两个array，然后我要把他们挤在一起，搞成一个，然后我就可以做下一步运算了，我把这些运行一下。这是概念，把他重算了一下，你看，我们先把刚才生成的体重，身高拿出来，然后我们知道这个体重的均值，就可以用这个来算一遍，然后我们算一下他的方差，标准差，再打印出来，跟刚才是一样的，不是完全一样，我们可以退回到刚才的数据，168 55 5977.这说明什么，我们用那两个指标生成一大堆数据，我们反过来再拿着一大堆数据再算出来这两个指标，发现能跟原来对上，没有问题，说明generate的数据有代表性，还是恢复了这个分布，然后下一步，我在这里，这应该是我们第一次用这个库吧，calculate。原来我写着一段的时候没准备用pandas，用pandas也有类似这种表格打印功能，搞一个小尺寸的库。因为现在我们看的数据比较多了，除了我print这样四个数的话，你可能就没有概念他在说什么。有这个label就比较好看一点。很简单，算所有5000个样本的身高体重。然后我们一旦算出来，我们也可以重复刚才那个步骤，比方说知道上海地区成年男性他们身高体重指数的均值，均值是多少，方差是多少，我们就干这件事。你看，非常straight forward。均值，方差，这是一个vector,求mean的话求出来是一个值，基本上都是比较瘦的，体型比较轻瘦的。跟大家的印象一样的，可能去东北就不一样了。写方程组，这个就有一些线性代数的符号出现了，大家先回忆一下。能直接解出来吗？口算。其实我不知道以前上学的时候求解方程组，老师说猜不算一种方法，猜不算一门解，我猜出来了，但我告诉你，猜是最有效的解法，你会发现所有方程组的解法，本质上就是猜。他是系统性的猜，非常聪明的猜，你可以看牛顿法解方程组，其实本质上就是猜，包括求微分啊，猜是很有效的办法，因为我只要让运算成立就行，只不过我们讲的这些所谓解方程组的方法，猜听起来很不靠谱，虽然你可以不用猜的办法去解，但你至少可以用猜这种思路去验证，我已经算出来一个解了，我用一下，看一下能不能成立。他概念很简单，不要看他这么写的一大堆。这是我们数学实现，我们怎么搞出来一个matrix,,我们不是写成这个样子，我们是要弄成这种表达式，这里有一个matrix,然后这里有一个向量 2x2的，两个元素，一维的。你看，长得跟刚才一样，这里有两个，一个是方程右边的V，他的shape，然后是两行，定义，然后是A的shape，就是你开始脑子里要有shape的概念了，因为shape跟不上的话，你是没发成的。线性代数里面这是一个主要的问题，然后你看我们调用了好几个，其实是故意弄的。

## 6

如果我看见一个错的，那我就可以去调这个shape，注意啊，shape不是一个function，你不能加一个符号去call它，他就是一个tuple(数据类型)，就是把两个数搞在一起。矩阵的索引，我们就用A来做一个例子，这是你最直观的方式，我们现在是一个2x2的矩阵，我们画了一个图，就是行的索引，列的索引，跟你想的是一样的。好，有了矩阵以后，我们就可以进行下一步。矩阵运算，矩阵运算使用他的一个库，注意，应该是线性代数算法，然后我们大概看一下，有多少同学对eigen value, eigen vector还有印象，翻译过来叫特征值，特征向量。比方说你去看国外的讲义，他没有这些我们国内的翻译，但它其实就是这个意思。然后矩阵的秩，今天我们cover一个比较重要的内容，inv,矩阵的逆，想象成倒数，单位矩阵就是对角线上全是1的矩阵。我们已经离开numpy那些general的部分，数据类型啊，那些运算，刚才我们举了一个例子应该是随机分布，那个其实已经是数理统计领域的东西，然后我们现在看到另外一个包出现了，就是线性代数的包。这就是我刚才说的矩阵求逆，就是相当于求个倒数，他就是有四个数，suppose他乘以A能得到一个单位矩阵。其实你乘一下不是那样的，是有误差的。
这个第一次出现，他是代表矩阵乘，你也可以写一个复杂的形式，但是你看我又做了一下round，出来一个负的，然后解方程就是这样，一个方程组的一个系数矩阵可以求逆的话有个特别简单的解法，逆矩阵乘上右边那个向量，你会看出来很直截了当，这就是解方程的方法。一个矩阵是不是可以求逆矩阵，是不是有解，这是另说，以后会cover，但是basics idea就是这样，可以用这个办法来解方程组。逆矩阵乘以b求出来了，跟大家想的一样，1和2.所以他是有点用的，你现在拿出计算器来，你很难去解方程组，但是你有这样的工具，你就能解方程组了，能解方程组就能处理一些很复杂的问题，其实所谓线性模型，最后也有这一步，解方程组，求解这个参数，我们后面讲的课基本都在干这个。还有个简单的写法，这是数学原理，这些问题都可以研究的非常透彻，怎么求逆矩阵，怎么样减少计算量，有很多方法，大家有兴趣可以去看paper，他其实一直在发展，一直到70年代80年代还有新的paper,然后这些想法就被加到数据库里面，我们现在用的应该就是其中的成果吧。但是在数学上这就是一个简单的问题，要计算及实现可能底层会非常复杂，但是我们知道这里有个调用叫解方程组，有一个参数矩阵，一个系数矩阵，一个常数向量，我们就把这个给解出来了。然后数学上我们把他写成这样。
下面再回过头来看一下numpy，不是说后面所有用到numpy的我们都要过一遍，这个也没有必要，大家都可以去看文档，还有一个办法。。。。后面我们的课有一个很大的gate，大家有checkout吗，AI-U，那里面code大家有看过吗，比方说：这个目录下面有很多code，你们后面的课就会讲到，尤其是这个里面，这里有很多markdown,就像我们这个jupyter的这些文档一样，这个source code还没上来。。。看这个folder,他应该在后面的课，这门课，第六节会教你怎么搭建一个神经网络，只用numpy来搭建一个神经网络，然后我们可以看一下folder下面有很多python code。这里面提到一千多字跟我们numpy乘相关的东西，我们大概看一眼，里面有非常多的乘，就是刚才那个@符号。我们可以stream一下，上节课我们把录像里面的字幕做了一下清洗，然后我们来统计一下，整个code里面都调了哪些function，然后我们提前去看那些method，感觉上很集中。下面我们在做一个小的题目吧，这个code比较长，所以我们不要用这个ppt的模式，random work是一个什么意思？就是我们刚才搞了一个期望，标准差然后整个人的体型的分布，然后我们现在有另外一件事情，一个物体的运动，我们把他的运动限制在一条线上，他可以有看起来很随机的走法，他每走一步，可能就会探测到一个点，假设一只小蚂蚁，放在上面乱走，就像一个扫地机器人一样，然后我们看看这些随机的行为，假设这是一个我们要探索的空间，探索的过程当中会有哪些点，这是一个办法，如果你能在一维上做这个事情，那你也能在二维上做这件事，很多时候我们找所谓解，我们要用我们猜的方法，第一步就是随便猜一个值，然后你也不知道这个值好不好，然后你算一个结果，最终离你结果远了还是近了，你心中有个数，然后你就朝着最有可能到达目的地的方向前进，然后前进一步以后你再算一遍，然后你就这样一步一步接近，但是你也可以假设我不知道这怎么算，我离目的地是远了还是近了，那我下一步还是random，然后希望某一天我正好碰上 ，这也是一种办法 ，一般的解法都是这样，算法的基本想法就是这样，有几个名词注意一下，procedure就是在计算机里面叫面向过程的编程，就是我写一个简单的函数，这里面有面向对象，这是一个oo的实现，然后oo算一遍，然后这是一个IU的实现，我们用这种直观的方法做一遍，这里有一个acc，accumulate的缩写，这是Python的一个module，然后最底下这个，有一个numpy的实现，然后有这么四种解，我们来运行一下，大家也可以看到运行结果，类似的事情又出现了，这次差别没有那么大，但也有量级上的差别。然后有一些东西你是可以解释的，比方说这个oo为什么比直接写一个function要慢一点，不是慢很多，大概5:4,80%，我们看一下，关键这一步是一样的，选下一个点，胡乱找两个从0-1的数，给他加起来减一，这一模一样，为什么他会慢一点，最后这一步是一个for循环，我其实就像得到一大串随机点，run1000遍，就有1000个数出来了，但是这1000个数你要注意，你的上一个数跟下一个数是相关的，你是走到这一步之后再做一次random，所以你在现在这个位置上再往左边走，右边走，然后你再做random，然后你整个轨迹记录下来是一系列的点，比方说你每次random的点都是1的话你就走出去了，我就顺着数周的方向很快跑掉了，想想一下这个过程，然后他们为什么会有这个区别呢，我觉得惟一的区别就是这一步，这里面有一个function call，然后我们再看下一个解法，这两个解法算法其实是一样的，他就是说我先不要一步一步，我先random产生一大堆数，1000个random的值，然后我把这些值来做累加。比如我每次都是random 1，这也是其中一种情况，这是上一组数组的累加值，累加值也是另外一组数组，你想一想，肯定有一种比较低效的做法，每次都从头累加。你可以从这里加，会有越来越长，然后用这个类似的，这是用
Numpy的方法，算出来的结果，不是语言上的区别，有些的实现比他效率高点。大家也可以试一试这个，比我们上一次run的0,1，-10要复杂一点。
我们加快一点，Scipy是我们刚上课的时候放的图，底下是numpy,上面是scipy,因为他比较大，有同学问他底下是什么C库，然后我们知道C的东西，他编译了以后不会是一个.py这样的，他会是一个在linux上是.so。大家可以把这些粘贴你们terminal里面去试一下，鼓励大家动手做一下，你动手装一个库，查阅document,当然你还有另外一种，view board，就是你直接去看他的code，直接去干什么，有一些hi-level的印象，大家可以去试一下。   

## 7

或者你知道我要干什么，就是给大家一些直观的印象，你把这些用到的库都列你们的环境里面出来，就是copy,paste就可以，你们这些环境里面肯定都一模一样。我们在看有多少个SO，sh滚了一屏，数数个数，然后再看看他们的大小，打消我没记错的话，大小numpy在10兆左右，25兆，我删掉了一点，他有些软件包我们肯定不会用的，比方说我们整节课都没有touch过傅里叶变换，numpy就是原始的安装大小，然后也可以给大家一些印象，比方说matplot和pandas，应该pandas比numpy还大，因为这个东西一旦牵扯到io这个数据量就上去了，他要处理各种各样的情况，下面我们也会cover这个问题。先让大家有个印象。
这是我从他的document中找出来的表，就是scipy包括哪些东西。这个cluster不是集群的意思，kmean就比如这些点把他们的中心点找出来。其实傅里叶变换是一个很有意思的topic，他能把所有时间序列变到频率上的东西，听起来好像没什么意思，太了不起了，如果你能把一个频率上的。。。这是一个实域上的东西，我现在画的这个正玄波sin，你知道这些正玄波，余弦波都有频率，这是比他频率高一倍的波，他的意思是你可以把所有的任何在时间序列上的东西都变成这种频率的组合，傅里叶变换讲的就是这个事情，我有一个时序上的，这个时序不一定是sin，他有可能是股票价格，他也就是一个time series,然后你就可以搞到一个频率上，如果你搞到一个频率上意味着什么，意味着你可以把他分开，就是一个东西你把他踩碎了，拆成一串东西，就便于分析，有一些东西还是挺有意思的。大家用过录音软件吗，他有一些visualize的，我的声音，我们知道声波是一个波，但是你会看到有些东西随着我的讲话他在变，很多人说这就是我的波形，其实不是的， 大家以为这样的，这里有个方块的，然后这里还有些音量的东西，还有颜色不一样，然后你说话的时候会发现这些东西会非常快速的变化。他这个东西一旦动起来你在视觉上就会有个很深的印象。我其实可以只看这个图就把比如一个男生和女生分开，男生和女生的频率不一样，我把这些频率提取出来，然后这个人发音的一些特点，更有意思的我还看过一个用机械装置，假设你能做一个木杆，然后我在这上面再搞一个木杆，相当于有很多东西，这些东西转的速度可以是频率，你拿这个木杆甩，甩是五花八门的pattern,你可以画任意曲线，真的，就这么一个简单的东西，这就给我们一个很大的启发，比方说我们后面可能要讲级数，泰勒级数展开，变成多项式。通常来说，比如这个积分，我之所以把这个库加进来，之前没有，因为我发现后面有的地方要求积分。Numpy求不了积分。求积分有一个专业的软件包，这是做差值，这是做io，这是做线性代数，这个是做图像（image），这个是算距离（正交距离），这是做统筹学，OR优化的，这是信号处理，然后系数矩阵，空间距离，如果你用dash这些东西的话，你可以看到更detail的东西，因为他在下一层。你看这线性代数里面有很多，cython_blas。先到这吧，下午继续。

## 8

咱们继续，这个是刚才的电脑的更详细一点的东西，你看，他有这个系数矩阵的线性代数算法，好，我们，go on， 这个，这个就是我们上午吃饭之前我们看来一下这个库的情况，这个库分别有多少个依赖的包，这个包大概尺寸是什么样的，现在我们看一下这些依赖包里有又依赖，因为这个shell的object它是可以形成一个依赖树的，就是你叫我，我又叫了其他人，然后这样一直叫下去，我们再往深挖一点，看看它一共都依赖些什么库，就是结果其实是很，我来稍微解释一下，这就是会把这些文件打印出来，然后后面这个zip其实是生成了一段命令，他的意思就是说，前面不是有一个so吗，然后我在so前面加了一个ldd，ldd就是可以把他的引用的库打印出来，然后把这个库打印出来就会出现一行一行的ldd什么之类的东西，然后，我们把这个东西给一个，这里有一个sh，看到了吧。这是一种经常用的技巧，就是，我等于是到这里为止，生成了一个脚本，然后我把这个脚本又给shell，然后这个shell就运行这个脚本，这个脚本里面有多少个so就有多少行，然后这每一个so打印他的依赖关系，所以你可以想象假设我有200个so，我可能打印出这个1000多行的页，然后，我对这个文件再做sort，uniq，我就知道所有的这些so所得有依赖库都有哪些，大家可以试一下，把他们都打印一把，就是我们这个课它没有cover就是python跟c的接口的部分，我们只是用这些c库，但是我觉得大应该有这样的概念就是，要到folder下面去，就是这个folder，到这个folder下面去再打印，大家就可以看到打印出来有一些库被列出来，其实很少，你可能很吃惊，他其实就依赖几个玩意，所有的这一整套东西，都跟数学相关的，我们可以把它们都领出来，基本上就是这个两个库，也就是说，包括后面的什么pandas，你们再往后可能会用到pytouch，huge的freework，它底层用的库还是它，就是，什么意思，然后我们看一下这两个库的网站，看看是谁在做的，这是一个gcc，gcc的数学库，gcc是一个编译器，大家都知道吧，就是vitual 的作品，就是可能现在大家用的c编译器有，我知道ls，前几年换掉了，然后，安卓底层的还是这个东西，然后现在你在unix，你们现在在用的，他更client差不多，然后，这个c库在干嘛，我们来看一看，这个大家还有印象吗，大家做的题里面好像有一个幂函数，就这个，就是一种函数形式，然后大家看，大概有和印象就是，三角函数啊，这个是三次方程，开平方，做边界值，算e，绝对值，就是，好像是一些零碎的东西，好像有一些差值函数，就是一些数学工具，就是一般的，就是c库里面已经有一些这些工具，然后，什么sort啊，然后要算一些sum啊，都有的，平方根，但是这有一些些高级，还是，你也不好把它放到任何一个数据库里面，就是说一大堆，你可能会用到，他就把他放到这，然后这些所有的这些数学工具都有快速的实现，还有些复数的东西，没了，就这些，这个库很简单，你数一数就能数出来，100个左右，这肯定是一个小库，这里还有个大库，我抄了一段它的文档，这个就是你经常看到的，为什么你经常看到的是因为你要自己手动的去装，scipy，你会碰见一个编译错误，告诉你这个库，很粗心它的意思是基本，线性代数，他是干什么呢，就是向量操作，然后举例向量的操作，然后举证的举证就是这个东西，然后它自己是在这个食物链的低端，食物链的低端是什么意思，就是说，不管你是什么样的动物，反正我是草，就是你吃来吃去吃的都是我，就是我们现在用的这些库，numpy，scipy，就是你感觉它好像是一个Python的库，他不是，他是伪装成一个python仓库的c库，他大部分的事情是在调用底下的这个东西，所有的实现和计算，然后为什么他就是很难被替代掉呢？这个东西很早就有了，我们看一下它的git，看，然后你看这个库他标记的语言，这里，forturn，它是一个这个语言的库，如果你去scan一下他这个库，他是forturn source库，他是一个很早的语言，他到现在都还在用，他一开始被发明出来就是用来做科学计算的，就是做线性代数的矩阵运算，统计，各种优化，然后这些库被调的，然后几乎所有的bug都被fix，然后他是一个很稳定的，经过时间检验的一个库，很多年过去了。大家发现没有必要去替换他，然后把forture编译成一个函数，上面我们说你看到一个so就是c语言编的，但其实这个不是，所有的语言都可以编，他里面也有c，他不是所有的都是forturn，可以大概的看一下其实你看这些库其实是很有意思的，然后，这个上面有3000个commit。我们现在在用这个，手机上应该也可以跑起来，这是一些汇编，这个东西大家谁知道sse，sse就是一个指令集，它很宽，现在是64位的，他可以是256位，512位，他可以同时算很多并发的算上面数据，充分的利用了处理器的性能，当然，它做的代价就是这个指令集只在这个上面。这里有一些c，它用c来做接口的，就是其他所有的语言都可以和他很好的街上，就是关于这个语言的接口，如果你写了很多和性能相关的程序，就是你总归会touch到这一点，你的代码进入到c，进入到汇编，你需要到一个很平滑的，把一个object传递到c里面，你知道c他是没有什么对象这种概念的，它这里面py object就是指针，我们需要知道它是什么，它其实就是指针，就是一堆list和一个指针，然后，然后所有的东西都是靠指针来操作的，然后就带来一个问题，就是我如何写一个能把这个语言的object. 赶到c然后c call了以后，return 的值还能被传回到我们，就有很多做法，这个做法就是提供了一个c的接口，还有一些语言，有自己的接口，ffi他比较方便，大家看一看这些库就知道自己所做的运算之所以快，不是因为他写的那么高明，是因为他在用一些开发了很久，本身写的很好，考虑到很好的库，不是用python写的，但是python可以用这些，python可以用自己的c的接口去调用这些c的库，也可以回答一些问题，就是说，内存啊，allocation这些啊，他就没法allocate，没法做什么内存管理，manage 你的 memory，不是在numpy，python这块地方。给大家讨论一下文档，我们今天上午讲了那两个库，一个numpy，一个scipy，今天下午还会讲两个一个画图的，一个做数据处理的，一共讲4个库，然后我们学这个库的原因是表面我们以后要用，下周的课，明天的课马上就会用，所以我们要事先知道，但是，有一些问题我们马上就能给出一些答案，比方说怎么用这些库？去哪里找文档？我想实现这个功能，有哪些参数？这些问题都很好回答，但是，但是我们是要往上拔高一才就是说，我们怎么使用这个库整个的结构，也就是说，任何时候就是，当我们做一件事情的时候，我们要获得某种安全感，安全感的意思就是说，知道自己在哪，我没有迷路，我知道自己是在朝我想要去的方向前进，然后我看这些文档的时候，我在开始给大家展示了一个toc是吧，包括我们刚才练了一下这些scipy的模块，然后你会发现这些文档对一个库有一些特点就是，他基本上都是遵循同一个规则，是一个二维的导航系统，这个概念其实不是说的最多的，其实最多的不是在这些文档，这些库的标准里面，他其实是从那些UI里面来的。

## 9

大家有没有印象，应该是2007年，乔布斯在发布iPhone的时候，他给大家演示他的新的UI，第一个smartphone，UI设计的setup，以前的app没有一个桌面，没有icon点进去，你回忆一下那个发布会，就是当时这个界面是这个样子的。这个什么意思，就是说这个能到上一层，这个能到下一层，然后这个可以上下screw的东西是本层，所有这些模型你都可以把他变成一个这样的结构，不管怎么样，我们都知道在二维坐标内身处何处，因为这里有title，告诉你现在在哪儿，然后你可以rack，安卓做的比较好，然后大家机会没有任何障碍就接受了，你也可以不这样，比方说desktop,桌面系统，桌面你可以拿个鼠标哪都可以点，就相当于你并不是在一个固定的路线上走，我想去任意一个地方，然后我戳的这个地方还有contest，他的这种导航的概念，你不用学，你很小的时候就有这样的概念，把他们组织起来。我们去看文档的时候，我们要去利用他的结构，比方说我们不会一上来就很detail ,我们会先过一遍，这是最高层，先看list,再深进一层，当你这样做的时候，你就知道这是一个很大的库，我们不可能讲的，比方说我们今天一个一个看也不可能看完。通常你就会沿着一个路线，把这些东西组织成一个树形结构的话，就相当于这个是层，然后往下深入一层，你会走过一个浏览路径，你会顺着这个路径走下去。比方说线性代数的算法，数理统计的另外一个路径，不管你沿着这个路径怎么样探索，这个很大的文档结构，你总是知道自己在哪一层，这是一个大家要记住的东西，我们看这些文档最好的地方就是，文档不是一个博客，大家说一说，表达一下都是可执行的，如果最后不能落实到执行上，那你看这些文档就没有意义，为什么要看文档，你是要淘你的代码，运行它，你要填参数，然后你要看结果，所有的这些你可以利用的这些资源，有没有人没有用过这些东西啊？或者不知道这是啥，这些东西就是利用。比方说我们这些搞技术的，程序设计啊，编程啊，我们去用Google，我认为90%以上把你指向网站，因为Google本身也是快速回答问题，相当于stackoverflow把index给Google，他一开始就是这样设计，他就是要让Google来搜你，所以你在Google搜和这里是一样的。它通常会有一些sample，你提出一个问题然后问怎么办，然后我的回答就是一个sample，一个sample意味着你可以试，我可以copy，看到结果，解决我的问题然后我们现在用的这个形式，比方说notebook，他有有input,output，我可以试，可以改，还有一个东西，我想跟大家说的，你看所有的代码，他之所以可以让你看的原因是他有结构，他不但组织上有结构，他文档里面也是有结构的，而且这种结构就是来省你的时间的，结构是什么意思，你可以忽略掉大部分，比方说我们刚才也看到了很多文档，你可能没有注意到，我的behavior，我根本不会去看前面的description，我会screw到下面的code，因为code好读，文档字多。Code有个好处就是他到底行不行我马上就知道了，我可能还明白他是怎么讲的，但是我发现他不行，那就不需要知道了，不需要明白了。如果他行我也不需要明白。但你要想想如果别人不做这个文档，不管他的结构的话，我们就不能知道，也可能找半天也解决不了这个问题，因为它可执行这非常好，一定要利用这一点，你看，程序员读的文档和平常文档不太一样，其他文档比如说政府的报告，学术的paper，他也有自己的套路，他也有自己阅读的惯式。然后你为什么提出这个问题，这个问题有没有意义，我们文档里面从来不讲这个，这都不用想。还有就是索引，我们看这文档有结构，我们去找一段可以运行的代码，Google是一种索引，然后我们用的这个工具dash也是索引。索引他运行的速度非常高，也就是你可以很快地查，某种程度上它变成了你的一个工具，你可能一开始并不了解全貌，但是你通过反复用这些索引，你在这个很大的数里探测很多很多点，然后这个整个的经历在这个时间序列上排，你会对整个库有一个概念，你会形成一个，虽然他是一个线性的，但是你经历的时间久了你就能get到这个东西。
下面讲的就有点高了，因为前面讲的这三个怎么去看文档，结构化，运用dash去search，去找时间代码，就是我想找一个答案，然后五分钟之内我要看到结果。那下面什么叫做利用批评？ 他是一个更高级的问题，那么他的时间跨度可能是天，月，甚至更长，比方说我们要不要用numpy,我们要不要用python，你可能没问过这个问题。什么叫批评，就是说没有东西是完美的，我们现在用的这些库，我们要从一开始就有种观念，它是需要改进的，以后还会有更好的，那你怎么去知道这些information，这些information跟前面不一样，前面这些我们能找到，但这些是不会公开的。比方说这个小站的首页是一篇大碗的文章，不会的。这些文章为什么会有价值呢，因为这些作品一定会去hide一些东西，就是我写了一个东西，你们说是垃圾，然后我肯定要反驳，然后这里面整个精神，就是你要全力以赴去反驳他，然后就会有很多精彩的东西，有些人很会用这一点，乔布斯开会讨论他有一个trick，他经常挑起争论，他的目的就是让人家吵，你说A好，他说B好，如果这个东西你提出来了，你一定觉得这是对的，要不然你为什么说，然后现在别人说你这个不对，然后你改口，说明你原来的想法是有问题的，你就没有坚持自己的想法，他愿意去看别人坚持或者捍卫自己的想法，所以他们challenger别人。你们有没有面试别人的时候，别人会讲我做了一个什么项目，以前的工作经历，你通常会怎么评价他，了解多大程度上参与了这个项目，其实最好的办法就是批评他，原则是这样，不管他说什么，他做的都是sh*t，你可能根本不同意，说你做的这个不对,很多人的反应是这样，好像你说的有道理啊，其实这就没有什么聊了，就是有价值的information, 就等于把他的经历很高度的概括出来，他如果要捍卫自己，他肯定不会说一大堆废话，他肯定要讲关键的点，关键的点其实就是他最care的点，或者他想隐藏一些他没有做好的，他fail的，他当时有什么design的错误，后来能不能改正，所以这是一个非常好的trick。所谓不破不立，你要首先看看他有没有什么漏洞，基本上存活下来的或者被大家广泛应用，是已经被大家challenge过了很多遍，能挑的错大家都挑过了。所以引出来下一个问题，我们前面讲的这些技巧，技术水平，比方说这个人执行能力强不强，他在回答两个问题，我们应该做什么，怎么做，通常他不再关心我们为什么要做这个事情，还有这个东西他从哪儿来，谁搞出来的，就是现在我们在搞这个AI，deep learning，有谁仔细想过我们为什么干，why，他有多大benefit我们才要干这个事情，当然你有很多现成的答案，到底谁在推动，比方说整个pc的时代，指出这么一两个人来，他们是非常关键的人物。比方说互联网的时代，扎克伯格。Mobile的时代，乔布斯，我们这个时代，没有。有一些技术上的人，他不是这种level，并没有一个industry，为什么要考虑这件事情，你看有很多时候，你知道怎么去做它，你知道应该干什么，并不代表你有很深的观点，只是一个效率非常高的执行者。很深刻的观点带给你的好处是什么，他能极大提高你的效率，因为如果做过性能优化，有一个基本的方法，不管你具体什么方法，但你肯定要按这个套路，你首先要掌握这个系统运行这个数据，你要知道什么地方最耗时间，我要说finding，然后采取针对最大块把他搞掉，我的性能就会拔高很多，然后我再想找下一个。如果我能把自己整个career，做一个非常大的事业，你用这种观点来看，肯定有很多极大影响我们效率的东西，我们怎么来把他给指出来，观点如果把它去掉，我们能剩多少时间，其实你最省时间的办法就是你不做，就是很多事情你不应该做，确实是这样，不是不停地做而是不做，你不做显然有个观点，谁做的，干得怎么样，这个information跟具体document没关系，我只有非常清楚这个答案以后，我才可能驱动自己怎么去干。
然后讲一些形而上学的东西，没什么用，很远，天马行空。我们怎么来考虑这个问题，我们应该去有些观点，怎么去找，我觉得有这么几个技术，这个跟技术文档不太相关了，这是我自己的习惯，任何时候你要identify关键，你还记得我们第一次上课，我要知道这个人是谁，因为我对python感兴趣，这个人在干什么，是不是有意思。
什么叫观众视角和舞台视角，你读了他的故事，你觉得挺有意思，你怎么去理解这个故事。

## 10

舞台视角和观众视角是讲我们focus的这个人的观点，比方说他是怎么看这个事件的，比方说我看他们的传记，另外就是他不是在评估他自己的生活，他是在一个大背景下生活的，比方说中国有很多杰出的历史，中国文化的长处就是写历史，最早的历史著作像左传，春秋，史记，资治通鉴，基本上就两种题材，一种是史记的体裁，叫纪传体，看他的目录上千行。另一种就是按照时间顺序纪传，这两种体裁都非常重要，因为如果不是关注这个人，你是没法深刻关注这个事件的。最终真正产生什么影响的是因为你决定做什么，而不是你看了什么，你看了再多也没什么影响，一个阅读者。一般来说，你take action，你一定是有所行的，这个东西要先有一个判断，然后根据这个判断来决定是不是要做。那些小说里面讲的那些事件是为他的观点服务的，这点非常非常重要，他其实就想宣传，这个任务不是复盘这个实情，他是要宣传这个观点，然后这些事实服务于这些观点，不服务于他的观点就要改，改成服务于他的观点。这些观点有很多指向性，学历史是为了让你记住这些观点。
我们把这个应用到我们这个领域来，要下来做一些具体的事情，我们希望得到一些指导，insight.我们知道一个东西他从一开始行或者不行，为什么行，理由是什么，我们需要这种东西，这个东西work的基本原理是什么，然后我要有这种能力去识别这种pattern，因为我们会反复的遇到类似的情况。不能为了库而库，这是非常容易犯的错误，千万不要忘了自己要解决什么问题，用的任何库都不是完美的，他是解决问题，但也带来新的问题。
一个问题他总是存在，然后大家会一代一代得解决，就是通过刚才我们看的这些库，从fortune的时代就开始记。这两个库很早就有了，反正我印象里面有python语言不久就有这个东西，那个时候python不是用来做machine learning的，他的focus群体是科学家，你们会发现这个问题的存在。Problem要比solution长久的多，你需要用这些实验主义的思维去分析他们，可以叫framework也可以叫library。是两种套路，就好像我现在要建一个房子
，library等于是一些建筑材料，至于怎么建是由我自己来决定的。Framework就相当于我这里有一个架子，他必须在我这个架子里面。各有利弊，你也可以简单化为一个从顶向下的设计，另一方面从底向上的。这些用户会怎么看待你，你肯定会想这些事，也就是说我也做了一个东西，他也做了，一个用户说我应该用哪个，他根据方不方便。尤其一个新用户，它非常容易出现的一种心理现象就是比较功能列表。
下一个是用户场景，好用其实非常关键，对于一个新用户来说，他其实最关心的是我能不能开始，我要上手，如果很难理解，很难搞定，我用不着，用不上这些feature。好用其实就看你怎么定义这个东西，你有两种方式，第一种就是任何技能你要掌握它，你需要过一些门槛，有一些思维的改变。你回想一下你真正掌握的技能，用户有一种很复杂的心理博弈的过程，说白里就是最粗暴的，就是能替你做所有的事，你就按照我说的，写一两行，点一点。

## 11

我们今天用numpy其实是有2件事情，我们知道他下面有东西，但下面是怎么做的，如果我们现在去写一个程序，很快速的去写一个程序能写出来，大家甚至不知道去哪里抄，就是你numpy能做，但你看了半天他的code没有，他的在下面，所以你要解决用户最大的痛点是什么，通过分析你得到，应用非常重要，那我就要搞一个让他一键式的。还有就是，现在呢已经有一个很大的用户群，你也知道他们最常提出的问题是什么，下一个问题就是你怎么管理它，也就是说，怎么样写一个，比如说web servers，你通常就和用户有关系，用户比方说要做认证，这里面最难做的部分不是登录，是退出，因为你要清理这些东西，清理这些season，很麻烦，比如说你做一个电商的网站，你完成一单，然后一个天然section，退货更麻烦，你退货的逻辑要复杂的多，所以，它要退出你要怎么搞，你当然不希望它退出，你希望了他登录了永远不退出，微信，一直登录，密码都忘了，然后，然后你还希望他用了以后介绍他旁边的人也用，因为它用了，所以现在出现了一个网络效益，就是像旁边人都在用微信，所有人都在用最后你不得不用微信，，就比如我们的作业群，就小孩作业家长群，都是这玩意，然后，你这个时候，如果你们达到了这个网络效益就相当于你用它的人际网络被锁定了，比如说你一开始说是因为它好用，然后可以解决他的问题，feature好啊，最后，总有一个时间点来达到自己的目的，把它给锁定起来，好，我们最后回到这个结论，就是，我们来做一个模型就是说，分析一下我们的行为跟这些写library的人都有什么差异，就是原来这个模型很简单，就是我们想完成一件事情，然后我们写这个东西去用就很好，他就写的非常棒，我们很感谢他，但是，其实你如果深入的想一下这个问题，从逻辑上来说，但某种程度上，你跟这些作者是一种共生的关系，但是，是有冲突的，并不是说共生就是很和谐的，狮子和斑马也是共生的，他们是有冲突的，就是一个freework，一个library他首先要解决的问题是他自己生存的问题，就是我们这个library要存活下去，我的这个项目要有未来，是吧？我首先解决这个问题，我为了解决这个问题，我会使用很多手段，。我要让你觉得我很好用，然后我加很多feature，可能我知道这些feature并不是一个好的选择，但是我为了在竞争中占据优势，我也会这么做，那就有可能会搞出一个很肥大的东西，99%的功能是你没有用过的东西，都是表面上看起来很简单，或者是开头很简单，就是后来会让你很痛苦，痛苦的原因是你离不开他，你被我给锁住了，这是我锁定你一个，就可以锁定你的手下，是吧？然后，你手下的手下，一大堆人，然后，整个就建立起来了，然后它会滚动发展，就是这里面有很多很多例子，但是，我就不说这些了。其实你看过去的web也是这样子的，一批又一批的freework，记不住，但是也去学了一些，学习学习感受一下，这个，今天我们后面的也是类似的问题，但是，我们怎么来举一个例子来说明这件事情，作者的问题不是你的问题，反过来你的问题也不是作者的，你要解决的是另外的问题，你的这种不是为了让numpy活下去，也不是为了scipy活下去，虽然你用了在某种程度上对他有很大的帮助，就是，我们看一个这个地方，刚才我讲的，我们来举一个example，比方说，我们看一个类似的patern，我们觉得他会再次出现，然后，这pattern背后的这些规律，或者我们发现的这些关系，可以apply到未来的市场里面去。在AI出现之前，在AI的浪潮出现之前，差不多有这么十几年，有二十年的时间，要解决的一个核心问题，就是你去在互联网时代里，你如何去做一个app，你如何去做一个网站，是吧？不管你做什么，那些user interface，它最终都会call一个web servers上，就是一定是这样子的，也就是说，这个web servers，在某种程度上，要能处理很多人的请求，这是一个非常核心的技术问题，然后这个技术问题应该怎么解？然后就有各种各样的东西出来。包括java，c shell，好像你换了一种语言，换了一种free work，你就所有的问题都解决了，其实不是，就是他没有解决关键性的问题，就是这个文章的作者，他指出了这是一种现象，就是我写一个网站，1000个并发，100个并发可以，但是过来1万个并发就不行了，这是一个关键点，就是他为什么会有这种现象？很突出，就1万个并发以上你的掉包啊，超时啊都出现了，然后你会花更多的资源去解决这些异常，然后你的性能就更糟，就我们今天早上讲这些语言，我们画了一个内存的图，它对应的物理事件background是什么？就是你知道我们这个领域有一些很神奇的定律，摩尔定律，摩尔定律就是说，可能18个月就会翻一倍，但其实它不是很准确，因为它说的是cpu，它说的是计算的速度，就是说，我们画的图的最高的level，假设这是开始1990年，这是2000年，这是2010年，这是今年，这个他提出这个问题是在这一年，我们可以画一条他这个指数增长的曲线，画出来应该是这个形状，这个cpu，然后，我们再来一条曲线，他也是增长的，你仔细看一下这个，他不是线性的，它这个是memory，下面还有条曲线，disk，network，我们再把它劈一下，就是这个地方砍一刀，做一个截面，然后这个地方，做一个截面，然后在这个地方再做一个截面，在这个时间点上，就是在2000的时间点上，那个时候大家用的解决这种问题的最常见的东西是什么？阿帕奇，阿帕奇它的解决办法是这样的，就是有一个requirest来了，然后你处理完了，然后放到库里，然后进行一个合理的，但是你看一下这个年代，就是，这三种之间的差距，有，但是不是那么大，到2010年的时候，就是这些大部分web servers转这个technic的时候，这个差距就直接很大了，然后到了今天，就是跟大了，就是，会变成一个非常明显的，10年间，在当时的那个时间点上，组这些事情，当时memory和cpu并没有很大的差距，所以看起来是合理的，所以，当cpu变得越来越快的时候，就不能handle了，因为这些年用户并没有等着，这些年全球就只有50个，现在可能有几千万个，用户一直在增加，而且在这一年，在这之前出现了手机，然后一大堆新的设备又上来了，所以你的request是越来越多，而且要求更多的experience，以前是图片，video，语言都上来了，这个问题会很严重，因为在2000年的时候你可以这样干，再往后你再这样干，第一，你没有这么大的memory，因为你经常会有一阵套的context给他服务，给他很多alloca，很多复杂的操作，然后，这个文章的作者他又，提出来一种解法，他就是往那个系统的下面看，他是做web server的，这是一个应用程序层面，他往下看，他要看操作系统内核给他的东西。我可以同时处理100万，是吧，这个是原来做法达不到的，通常你可以试一下，你可以去试一下，你很难高出100万个线程，几千个你的机器就快卡了，那他说，我就用这种方式，因为操作系统提供的支持，因为现在有这种background，因为cpu快，所以我让cpu去算，我不要去touch memory，我就让system给我一个中断，我去发现这上面有一些这个network上有一些数据要读，然后我就读，他只是一小片，一个package，无所谓，我跳到下一个，然后我再跳下一个，我总是在keep busy，我总是把网络上的数据往我的这个CPU里面送，那这样的一个好处是什么呢？是？你看我们要处理的是这个大的东西，这是io，这是CPU，这是你的CPU, 很快你的网络很慢，你那程序大部分的时间是在等，是在网线上等有新的package过来，你把这个东西去掉，因为你可以同时的100万个，比方说他们互相加起来，你的总时间就会大大减少，而且你的整个的编程的logic就会变得简单，你不需要释放，你不需要分配在释放，说白了很好理解，就是一个大loop，听起来很粗暴，但是它非常有效，然后，他就写了一个库叫mega这种库，后来他就发展成一个成熟的产品，他基本的解法就是这样子，就是你现在去看他的code，它的最核心部分就是一个loop. 我们回到刚刚的，整个东西这一整个叫一个packa，这有一个问题，是一个硬件变化，你的物理世界变化了，所以带来一些问题，这是解决方案，这些解决方案他有依赖些，这就是她的依赖，你要os支持，要不然你自己写一个，这是不可能的。他有一些很好的insect，他会在第一时间发现可以这么干，而且马上投入全力去做，你现在去看这，它还是第一，就是，比方说，大概在这个时间点前后，我发现国内很多创业公司在改这个Linux. 你会看见这个值，后来用web server，不管它上面的这一层，不管他web freework怎么变，不采取这种方法的，都会被淘汰掉，而且已经被淘汰掉了，你现在看见所有的这种，任何语言一定是这种方案，大家给他起了一个新的名词，叫athink，你在写程序时候，你不会去等他返回一个结果，你设一个call back. 你继续往下走，然后那个call back回来的时候，你的call back会被调用，比方说你这里面最著名的例子就是，Know Jack. 他的这个库给他加到JavaScript的printing里面了，它的基本的结构就是一个，linx加一个这样的一个库，这是他最早的版本，是这个样子的，后来改了很多。什么是我们这个时代？我们嘚向后看，什么是我们这种时代的background，就是大家可以大胆的想一想，就是说，硬件，系统，然后这个应用，都会发生巨大的变换，加起来就会推动这个行业的change，我自己觉得这个change有互联网要大得多，时间跨度也很长，你可以想，比方说，其实neural networ这些很早论文都是90年代的，basic idea早就有，为什么20年也才开始，之前大家不理他，为什么？我有些不是很成熟的想法，我觉得可能是硬件的算力方法，这是你能算出这些结果，因为有GPU一直在搞。

## 12

大规模东西，大规模它带来一种效率，就是说，就像这种neural network的东西，在数据量特别大的时候，他有很好的表现，就是，数据量很小的时候就显示不出优势来，但是因为你的算力够了，你就可以处理很大的数据，然后反过来用就可以提高你的性能，然后在这个点上就有一个爆发，下一步有可能就是什么，所有的东西都会搞到这个AI上，它会有新的network article，比方说5g新的网络，所有的basic. 硬件，图片，网络，这个研究，还有应用，他的变换的量级，都比这个小小的要大得多，但是，你可以识别出类似的，就是，想一想，我们将来的机会在哪，肯定还有人要用freework，我们还有生意可以做，休息一下后我们再过一下另两个库，另2个库我想过得快一点，我看看我们最后有没有时间讨论一下作业的问题，做作业其实是一个很好的机会。

## 13

我忘了是谁说的，他说就我们人类大脑比我们想象的要弱的多，也比你想象的要强得多，这里面的区别在于你能不能制作工具，大脑其实在很多程度上是依赖于我们做很多工具，然后我们用这些工具来帮我们，当然，我觉得这些工具里面可能最重要的就是语言，自然语言，写程序也算一种数学，还有我们今天要讲的那个，这是他不一定是图形的方式，怎么把这个东西可视化？他很关键是因为，他往往就是去改变你的思维方式那个点，那个关键点，就是你说在那个很多艺术作品里面，或者是诗歌这些古老的通常说，我懂了，他不说我明白了，他不说understand，他说i see这个意思，有个电影，阿凡达主题歌里面I see 他其实是梵语的一个音节，hans rosling这是一个人，这老爷子已经死了，然后，你去搜一下，他现在还在teg上，不是属一也是属2的speaker，有个东西叫ted，大家都看过吧，其实很早，80年代就有的，她的演讲，他就是搞统计的，偏社会学是个瑞典人，他的这些演讲的，每一个都水平非常高，然后，带给大家很多思考很多，这应该是他某一个，他有时候还是挺搞怪的，他本来拿一个这个就行了，他为什么要搞一个这个，然后这应该是他屏幕上的一个箭头，记者就拍了一个角度，看上去他像拿着一个长矛一样，然后问7亿个人都住在哪？其实就是这个图很有意思的，然后，我们看看他，一会就有个video。这是他的一个TED. 你们可以自己放，看他说什么，很好玩的。给大家5分钟。就是，你完全听不懂他说什么你也能看懂，你也不知道下面这些坐标轴是什么意思，但是这些泡泡的运动的轨迹，他们差不多在向左上角浮动，下面这个横轴市有多少个孩子？那个纵轴是你的预期寿命，然后很显然，他一开始有两个group，小孩子越多，你的预期寿命就越低，然后你的孩子越少，看起来不相关的东西，把他们都搞在一个，然后两个轴，还有轴的就是大小，要是总数，然后你会看到一个非常明显的趋势，就是全世界的人，活的越来越长了，家庭的规模变小了，然后是非常剧烈的，他是从62年，也就跑了一代时间，一代人的时间之内，全世界的人口就出现了变化，而且你在几秒钟之内就可以看到这个，你比较仔细看的话，注意中国，你会看到中国一开始很剧烈的变动，很激烈变动的意思就是说，因为我们有这些人口的政策，有计划生育，它会影响这个孩子的个数，这个指标来看他举的例子是越南，美国，人口分布的指标上面来看他，假设他在追赶美国的话，她差不多用了不到30年的时间，就跟美国1974年的时候，美国撤出了伊朗，美国不再影响这个国家了。看越南发展的轨迹，你会明显的看到了一个一个折线拐点，就是在那之前，他的预期寿命增长的很快，原来只有40多，你可以看到它快速长了这个，你会发现和家庭的数目有关系，孩子越少，家庭的经济负担也越少，这个video大家可以自己看一下，再把它看完，这个video他有一系列，这不是他最红的一个，这是他最早的一个，我之后看到他做过的一个更有意思的，他说我们不是关注这个小的问题，家庭结构和人口，而是关心一个比较大的问题，比方说中国的崛起，这是一个大的事件，你怎么用数据来观察？你怎么通过数据来获得？你怎么来project? 他那个topic应该是，就是，他关注的点是人平均寿命跟人均GDP. 他画了一个趋势。

## 14

我当时印象还很深，就是2048年中国的人均GDP会赶上美国，这是他的预测，它独立做出来的预测，就会发现他的预测跟中共中央的预测是一致的，这是2049年的时候，中国会赶上美国，在过程中你会看到日本跟美国的关系的变换，即使是非常复杂非常庞大的系数，你也可以通过这样来干这件事情，他不是一个武断的结论说，当然他说假的是有一个前提的，就是比方说不爆发大规模冲突，大规模灾难，就是照现在这样的发展速度能得出这样的结果，他的那些预测，比方说中国什么时候超过美国差不多也是对的。如果你是按照制造业和购买力来评价的话，我们讲这个就是来开一个头，就是说，数据可视化，其实特别有意思，在msra要个很大的一群人都在弄这个东西，就是一个副院长，他手下可能有几十个研究员，我在搞这个数据可视化，但不是只是画图，大家不要狭隘的想这个东西只是画一个图，就是这个图，你会发现它是一个动态的，而且，他后来演示的时候，他跟美国比的时候，背景里还是有很多国家，但是它会掉了，你还是能看到他的，但是你看不出一条轨迹，很好玩的，这个video后面还有一些他的，这个网站还能访问，这个例子就告诉我们，如果你认真做这个数据可视化的话，你能做到什么样的水准。这是十几年以前的一个作品，这是用一个flash写的，他想出来写这样的一个东西就很了不起，因为它的数据源都是公开的，就是这些东西在联合国，从那边都可以拿到的，真的，还有一些public的数据，谁都可以下载的，这个就是画图的，来简单试一下，我就画了几个数据点，世界人口总数，1950年的时候只有25亿人，现在多少？70多亿了吧，这个我也不用再多解释了，竖的是人数，你们觉得是爆炸性增长吗？线性的？那是因为你们没有看过更长的数据轴，他的数据轴很让你吃惊，是一个这样的曲线，这是在大概十几万年的时间就根本没有增长，这是工业革命，尤其是这个世纪，人口是爆炸性生长，这个图其实就你看的这个图，我是画出一个线来，它并不能给你一种insect，因为你的数据轴不太对，就是如果你把它弄到耶稣降生的时候，叫我很让你吃惊，就这样上去了，很有意思的，绝对是爆炸性的生长，一会儿我们就会看到一个例子，为什么画散点图而不是折线图？因为这些图是这样的，你给的这个数据找的顺序是，这个到这个这个下一个到下一个，一会儿我们来讲，下面还有一个，我们加了一个坐标轴的说明，这个年这个是这样的线，世界，这个数据处理不了unique，然后就是在进一步细化，这个其实是没有单位的，把单位加上，这个，b是代表billion，这个就是要把它底下的这个部分画出来，这个图用这个显示就是有点多余，因为一条线你也能看出是怎么一回事，如果有多个县的话，这个玩意就很有意思，你能看出来他的下面是这个颜色，他的下面是这个颜色，给你视觉上的highlight。直方图大家知道是一个什么样的，到时候我把这个数据找平均分，就是以单位长度划分为标准，我来统计比如2和3之间有多少多少，然后3和4之间有多少多少？然后画的时候其实我是以2个单位长度为一个bin，一个容器一样，你可以把它想象成你也不知道，这个数据点会随机掉落在哪？你在里面摆了一大堆的桶，往这里面开始乱扔乒乓球，有一些桶里面会有很多，有一些桶可能离得比较远，你扔进去的会比较少，然后你把这个画出来，大概的分布就显示出来你们也可以画一下。这个库matpltlib，是是这些库里面最没有什么可以讲的库，我们这节课下下节课都会用这些工具，你会发现都长得差不多，数据进来，然后show就那么几行，你唯一需要查的就是很多参数，就是，很detail的东西，没有什么原理性在里面。唯一可能讲一讲的是它有一个application，我们也用JavaScript里面把它用到Jupyter里面，你也可以弄一个三维的东西，你也可以zoom，你也可以time，但是不如它做得好，反正大家知道这个，到时候去查这个文档就行了，而且我觉得画图还有一个特别好的地方就是，就是这个code run完了以后它有一个对错的问题，你可能跑出来的结果是不对的，对，但是这个图对和错会非常明显，你一看就知道，图没画出来就是不对的，肯定有什么地方是错的，画的不对，画的不是你想象的样子，这你很好fix。另外一个问题就是，一般来说这一块是不会有什么性能的问题，因为这都是到了最后直接画结果的，从编程上来说它是最简单的，纯属一个工具，但是我们还是要用一下这个东西，这是一个方程，还是刚才那个例子，划成了一个矩形，然后你看我说的这个参数，都可以去查文档，我取了4个，这有多少个，这是2个。在中间的比较多，我们后面还会画很多这样的图，上节课讲的那个，体重身高指数的，基本上是个中心区线，越细越小，其实这个也是一个中心曲线，你觉得它太粗糙了，但他也是，我们来做一个完整的练习，sigmold是什么，这个看起来很简单的，我在这里给你们加了一个search，就上节课提到的worlfram，一个很牛逼的数学家它用到的软件叫Mathematics点一下这个link，看一下他的search 页面体验是什么样的？就是很不一样的。就是讲这个东西的。 大家都看一下，我们继续，这个函数是一个非常有意思的函数，就是它会反复出现，他会在我们这个课里面反复出现，今天先不讲它的数学含义，还有一些很好的特性给大家讲一下，我们把它实现一下，如果不有这些注释的话，会有一些错，如果你是一个特别小或者特别大的值，好像精度的问题，因为只说他的变化会特别，你给他e的x是一个非常非常大的数，就把那个公式抄一遍，它有什么特殊的地方，为什么要把它叫做sigmold？我们把它画出来，我是用了上节课的正态分布，我说搞一个正态分布给我，它的曲线会分布在一个-2~2之间，这里有256个值，然后我把这256个值都点出来，就是说，那个x轴是我的正态分布，然后把这个画出来是一个这样的曲线，perfect，它的光滑性，它的连续性，你视觉上是看得到的，这个是因为这个数据点不够，这也是连续的，他有一个什么样的好处呢？那就是，我们把它在这画一下，这个地方是0这个地方是1. 我再画一条线，这个比方说是0.5. 画的不好看，但是意思有了，不管怎么样都是倒过来，1是他的极限，不管怎么样，他也不可能小于0. 0是他的极限，这意味着你把整个数轴缩到0和1之间，不管你给我一个什么样的x. 我都能把它变成一个0~1之间的数，这个公司是这个样子的，假设x等于0. 这个是1/2. 假设x是一个特别大的数，如果x是一个特别大的数，这一项差不多就是0了，假设x是一个特别小的数，然后这个数会变得很大，然后就差不多等于1了，无论你是特别小的数，还是特别大的数，我都可以把你集中到1和0. 还有一个特别好的特性，就是比如说他在你在0的附近，你的变化很快，我们看这个数，你可以想象，如果我们把这个拉得很长的话，越往这你在外头上的增长空间就很窄，但是你在零附近你看，这个滑道是很陡的，一下就滑下来了，所以它可以很好的区分0附近的这些值，就是说很好的区分这些终止点附近的值，那么这意味着什么？为什么要弄这些东西？这其实跟后面的课有关系，这是我们搞的这么一个函数，好像是无中生有就来的，因为我也没告诉你从哪来，就写了个公式，那我们就开始画图，他有几个很好的特性第一，这个特性就是我们刚才讲的，它可以很好的把任何值都放到0和1之间，0和1之间让大家产生什么联想，这是概率，就是不管是什么情况，比方说我们想把我们想描述一个东西，就是比如说红颜色，我们也可以把红颜色数字化，他有多高，他有多重？这得五花八门乱七八糟的，你刚刚比如说身高什么毫米之类的，有什么米之类的？各个单位的量都不一样，他们相互之间怎么比较？你一定要把它们归一化，规划的意思就是说，我们要把它统一到0和1的区间，我们也可以从另外一个维度来思考这件事情就是，我们处理的问题可能是对应的现实世界的，这里有一个物体识别的问题，自然语言的问题，你可以把它认为是一些随机事件，都是这样子，任何就是任何随机事件，你都可以给他一个，随机变量，而这个随机世界物理世界的事放到概率学上，跟这个很像，其实它是正态分布的积分，就我们现在看的这个图是，中形曲线的积分，说到积分，就是你看这个线很光滑，刚好我们非常喜欢这个课题，因为光华代表着可以做微分。光滑的可以做微分，不光滑的不可以做微分，为什么，因为有人证明了这个，为什么要做微分因为做微分你可以做优化，你可以求起始点。

## 15

求最大值，最小值。就是我们后面学的那些，梯度下降，这些都跟事实上的一些运算，事实上我们永远在计算这些0~1之间的，他是perfect的，它很均衡，跟它形状差不多，还说你马上就能想起来，我们考试里有个题目也是类似的，也有一些不是这样光滑曲线的形式，这是非常早的，60年代70年代，大家都用这个来做，几何函数想象一下它有什么特征，然后那个就讲完了，因为后面还有大量的例子，画各种各样的图，所以后面的时候我们再看看，这写code其实你也不用记住怎么写，他基本上长得都差不多，你铐贝一下改一改就行，然后看下一个，pandas，这个库我可能讲的不对，因为我也不是很了解这个库，而且，我看这个库也很抵触，他是最后被加到这里面的，因为我觉得这个库太大了，这是他想干什么？他就干两件事情，io，然后就是像SQL一样的东西，我们可以看他，python也可以用，为什么要用这个库？数据库我也甚至可以import一个csv，但是他有方便的地方，一会我给你们演示一下，来，cia的数据源，大家不要觉得cia是一个情报机构，CIA是一个学术机构，他从一开始就是一个学术机构，他这里面的人也都是一些大学里面的教授，研究人员，分析人员，它跟谍战片完全是2个概念，在某种程度上，他在美国的知识界还是很靠谱的一群人， 然后我们看一下它的数据源，因为就是影响美国情报界的非常重要的潮流是，在二战末期，二战结束以后，冷战开始的时候，在做的data drive research，有很多很有名的人。美国的大学，美国的情报机构其实是一个东西，那你会看到他们非常重视这个数据的，这个其实相当于是一个数据库，他每年都更新的，就是大家可以随便点一点，你拿这个CIA的网站上面去，然后，它里面的一些数据就是一些国家的概况，还会搜集各种分门别类的数据，有好多，我们看一看，有地理，社会，经济，能源，通讯，交通，军事，Gdp什么，劳动力，股票，市场，预算，财政赤字，公共债务，进出口，也是一些非常总结性的指标，差不多这个国家是怎么说出一个数来，然后今天我们看的是这个数据，这些都可以造假的，因为你没办法验证，就比方说失业率是3%，但是作为一个劳动者，我并不知道这是不是，但有一些东西像这个，像这些不是太容易造假，这是你烧了多少天然气？用了多少电？我们关注一下第2项，发电，用电，点开以后你猜猜有多少页？我国显然用了很多电，我差不多是比整个欧洲日本加起来都多，但是没有美国和欧洲加起来的多，我们用掉很多电，大家注意一下这个数，这个是2016年的数据。这是可以下载，这个是一个TXT他不是csv，他这里面有逗号的，你要提取这些数据，还是要设置一些参数的，我们回答这个数据源，我们拿一下这个数据，run一下看看会怎么样，这是我们第1次用pandas，报错我是故意的，就是看起来好像跟网络有关系，报错信息没看懂，说什么，好像在说什么不能把它分开，解析错误，为什么，因为我这是read CVS，他不是一个csv, 他当然解释错误了，然后我在这里加了一句，还是不行，再往下，总之要加一大堆参数，但是你看已经加了很多东西了，最主要的是3. 分隔符不能是逗号，因为里面有逗号，分隔符也不是空格，两个以上空格，比方说，你看这些名字里面，在韩国或者什么的啊？阿联酋，有很多空格，但是它只有一个，我们找两个以上的空格，我们发现这个里面没有header，我们把它加上header，然后我们加上header以后就要给这些列设名字，我们直接从CIA抓了一个数据下来，然后把他clean了一下，然后我们得到一个这样子的表，这个是天然气的表，大概我们就记住前5个国家就行了，中国美国欧盟印度日本，印度差不多是我们的1/6，然后，有个天然气，这个天然气第一是美国欧盟，大家自己跑一跑，把这两个表搞出来，我们是要做下面这一个，我们回到刚才这个CIA的网站，你点了这个link以后，其实你只能得到这一列的数据，就比方说，我们其实想着这个天然气，他是另一个file，其实我们想把这两个列放在一列里面，这样我们才好比较，我们就搞到一起，然后大家看这是pandas特有的功能，这是以国家这一列位基准，把两个表合并，你可以想象有两个表，各自的排名是不一样的，消耗的数值也不一样，一共有6列数据，但是这6条数据里面有两类，其实是一列，就是这个国家名字，所以合并了以后会有5列数据，国家天然气的牌为天然气的消耗量，电力的排名，电力的消耗量，把它合起来，合起来之后就成这个样子，然后这个数据其实按照天然气的消耗量来的，第一是美国，所以你看中国的天然气的消耗量差不多是美国的1/4，中国电影的消耗量是美国的一倍多，为什么会有这个现象？你在宏观经济上怎么解释这件事情？煤炭便宜是因为，我们烧煤炭是干什么？是为了发电炼铁，炼钢炼铝也要用电，尤其是铝，要用很多电，然后用煤发电，因为我们国家天然气资源少，我们最近用的很多，为什么他的数据不是特别及时，是因为他2016年的数据，2016年发展很重要，政策变化，是取暖用电，全部改成天然气，其实它这个数据我们看不到出来，我其实也查过这个出口的数据，中国其实应该是第一，天然气进口第一，很快它的消耗量也会涨因为你就可以这样的想象，其实居民用电度数并不是很大，这是你日常生活要用电的东西，比如说冰箱，空调，微波炉什么的不是一年四季都要用的，这是功率很高，但不是耗电大，电脑也是一个，电脑其实挺耗电的，洗衣机，带烘干功能的，即使算上这些所有的店，他也不急，工厂消耗的电量大，制造驱动生产线，其实一个城市里面人用的电其实是很小的，就是如果你极端的设想一下的话，一个城市的供电，一艘潜艇是足够的，这是一个潜艇上的压水反应堆产生的电能，应该可以驱动一个中小城市，潜艇多小？直径才几十米，比方说现在中国的情况下，天然气也有用来发电，很多是用来取暖，还有就是化肥，制造化肥，2017年16年，他这个天然气供应就出问题了，导致化肥价格也涨了，因为化肥是把天然气当原料，挺有意思的一件事情，然后我们来用一下这个东西，sort，你看，这个主意，我们现在的这些变量，他不是我们前面讲的array，你可以把它想象成一个表一个table. 如果他是一个table的话，所有可以干的事情，他都可以干，查询分组，然后我们把它排一下序，看一下结果，这个综合的结果应该是中国，美国，欧盟，印度日本，这个表特别有意思，他跟那个GDP是完全一样的，在CIA的表格上也有这个购买力平价的计算GDP. 它不是按美元计价的话，货币计算差不多就是这个数据，就是如果算计gdp的话，其他国家都很搞下，但是你知道货币这个东西，它其实是一个剧烈变化的汇率市场，所以你如果用货币去计价的话，不是能看的太清楚，就比如说你通货膨胀之后就没有意义，我们就来一个实物比较，，你就会发现，像石油电力天然气，基本能反映经济状况，基本能反映经济活动，你为什么耗这么多电？肯定不是挖矿，就是生产，这两个库比较简单，我们用的时间比较短，大家有什么问题我们可以讨论一下。

## 16

这就是数据清洗需要的，因为都是准备好的实验数据，所以叫大家这个库呢，我们就介绍一下，大家某种程度上会用到，稍微用用就可以了，原来也没有加这一个部分，原本这个都不在课里面，但我觉得不管看什么，这4个库都是在一起的，所以介绍一下，了解一下，今天学了4个库，还有一个插件，我们下节课再讲，应该是在下下周的时候讲，向量操作什么的，就是需要有三维的东西，三维的东西你要这样旋转的，这样你才能看出这个东西是三维结构，vigit，绝大部分情况下就是一个二维的图片，就像这样的结构，因为你要可视化的话后面。如果我说你能想象就没有太大的差别，还有这个作业，大家发发意见，怎么搞法，有什么问题，希望我回答的问题也可以在群里发一下，我明天有时间讲讲作业。今天就到这了。
