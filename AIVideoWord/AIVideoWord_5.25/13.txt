来，先做个题，阶乘。当然这个题目还是有点问题。
阶乘就是，求一个数N乘到N-1个数。
我在这个定义里面就开始用这个函数。 
他的语法跟for很像的。我在这里面就可以引用啦。他进去之后又可以引用了。然后你就可以退出来。
这是非常power的。
你可以把那些七七八八的都表示为函数。这idea被一个人给实现了 有一个著名的语言叫lic。
我们看这个了。注意到，出现一个*号。他还得跑。我们就一个阶乘。你不小心写了一个很大的数。 或者什么一个死循环。然后你就会经历这种情况。就好像整个系统没有反应了。然后你就会发现这里有个新号。不是每个bug都给你一个明确的提示。
然后，这个时候，你就难以，debug了
他为什么会报一个错误。他说最大的maximum recursion depth exceeded in comparison
他好像陷入了一个很深的递归。达到了，达到了某种边界。跑了那么长时间。为什么？大家想一想，我们定义0了吗？所以我会一直乘下去。然后0往下乘，后面全部没有定义了。其实我们阶乘还是大于零的一个自然数。0！是1。0！不0吗？
我们刚才定义是一个递归的定义。我们把它改成循环。这里加了loop(n)。 
这样你就可以一直往下乘啦。这是另外一个实现。其实你们可以改一下当时那个条件。如果输入是零或者一点时候。他在阶乘都是一，就把它改对了。
自己去手动试一下。
这是我们看到的第一个公式。组合数大家还记得吗？知到这么回事吗？求组合数里面有很多阶层乘。
我这儿有五个东西。我同学吧。从这里面选三个。有多少选择？多少？大家可以算一下。这是他的定义。你们可以算一算，计算机硬算。
这个在古典概率学里面会经常用到的。
但是很简单，你可以用阶乘来实现，其实就是函数。你有一个公式，然后把他带入就可以了。
这就把公式重新写了一遍。改成了我们的函数。
大家可以自己试一下。这是一个函数。我们定义函数的时候我们知道他是个函数，这其实是没什么意义的。我们需要知道他什么意思？
或者是二元的加。他只是说了你的类型和对应关系，没有告诉你值什么样子。这是一个特别有用的思想。
然后我们再看max。很简单，求最大值。看到了吗？我们其实我们觉得是一样的值。其实是不一样的。刚才那东西。就是我们，我没改之前。他是输入类型的。然后没改之前是这样的。给他很多参数，他能处理很多参数。他是一堆整数变成了一个值。另外一个是一个数组变成了一个值。他们是不一样的。
方法。我们讲到这里，其实会看到一些面向对象的东西。然后面向对象的基本想法。我们第一个对象。然后这个对象有固定的的方法属性。
然后这里的数据是无序的。然后我们把它，sort一下。
你会发现sort数据是有顺序的。
到哪里去查这东西呢？
我们可以进入文档。
然后又有，然后我们就会找到很多方法。其实我想找的就是他。这是一个class，然后我要得到一个。
然后，这是一个reverse。其实是sort一种方法。
我们可以试一下。然后就会带来一个新的问题。我想知道所有的类型。我们试一下。
我们看到一个参数。方向。什么是方向？就是从小到大。他缺省的从小到大。我们把他从大到小。
通过查文档。我们发现会有个什么函数通过查文档。我们发现会有个什么函数实现这个问题。参数实现这个问题。reverse比如其他什么的。
因为一旦做编程。你的很多时间都是在，search文档。他是一个很长很长的列表。然后你又看到这么多的函数。你需要查找。
我们的数据是有域的。这是一个dict的，我们来把它排序。然后他的年龄。你发现它们都活的很久的。在那个年代，他们平均的寿命是30岁。他活了七八十岁，他们。
无名函数，他在程序员里面有特殊的含义。有名字反而是累赘。
还是刚才那个例子。从大到小排。刚刚试过了。按年龄排序。改个无名函数。我们返回age。他要输入是一个dic。返回lambda。